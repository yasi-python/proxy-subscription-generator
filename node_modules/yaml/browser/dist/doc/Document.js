import{Alias}from"../nodes/Alias.js";import{isEmptyPath,collectionFromPath}from"../nodes/Collection.js";import{NODE_TYPE,DOC,isNode,isCollection,isScalar}from"../nodes/identity.js";import{Pair}from"../nodes/Pair.js";import{toJS}from"../nodes/toJS.js";import{Schema}from"../schema/Schema.js";import{stringifyDocument}from"../stringify/stringifyDocument.js";import{anchorNames,findNewAnchor,createNodeAnchors}from"./anchors.js";import{applyReviver}from"./applyReviver.js";import{createNode}from"./createNode.js";import{Directives}from"./directives.js";class Document{constructor(t,e,s){this.commentBefore=null,this.comment=null,this.errors=[],this.warnings=[],Object.defineProperty(this,NODE_TYPE,{value:DOC});let n=null;"function"==typeof e||Array.isArray(e)?n=e:void 0===s&&e&&(s=e,e=void 0);const i=Object.assign({intAsBigInt:!1,keepSourceTokens:!1,logLevel:"warn",prettyErrors:!0,strict:!0,stringKeys:!1,uniqueKeys:!0,version:"1.2"},s);this.options=i;let{version:o}=i;s?._directives?(this.directives=s._directives.atDocument(),this.directives.yaml.explicit&&(o=this.directives.yaml.version)):this.directives=new Directives({version:o}),this.setSchema(o,s),this.contents=void 0===t?null:this.createNode(t,n,s)}clone(){const t=Object.create(Document.prototype,{[NODE_TYPE]:{value:DOC}});return t.commentBefore=this.commentBefore,t.comment=this.comment,t.errors=this.errors.slice(),t.warnings=this.warnings.slice(),t.options=Object.assign({},this.options),this.directives&&(t.directives=this.directives.clone()),t.schema=this.schema.clone(),t.contents=isNode(this.contents)?this.contents.clone(t.schema):this.contents,this.range&&(t.range=this.range.slice()),t}add(t){assertCollection(this.contents)&&this.contents.add(t)}addIn(t,e){assertCollection(this.contents)&&this.contents.addIn(t,e)}createAlias(t,e){if(!t.anchor){const s=anchorNames(this);t.anchor=!e||s.has(e)?findNewAnchor(e||"a",s):e}return new Alias(t.anchor)}createNode(t,e,s){let n;if("function"==typeof e)t=e.call({"":t},"",t),n=e;else if(Array.isArray(e)){const t=t=>"number"==typeof t||t instanceof String||t instanceof Number,s=e.filter(t).map(String);s.length>0&&(e=e.concat(s)),n=e}else void 0===s&&e&&(s=e,e=void 0);const{aliasDuplicateObjects:i,anchorPrefix:o,flow:r,keepUndefined:c,onTagObj:a,tag:h}=s??{},{onAnchor:l,setAnchors:m,sourceObjects:d}=createNodeAnchors(this,o||"a"),u={aliasDuplicateObjects:i??!0,keepUndefined:c??!1,onAnchor:l,onTagObj:a,replacer:n,schema:this.schema,sourceObjects:d},f=createNode(t,h,u);return r&&isCollection(f)&&(f.flow=!0),m(),f}createPair(t,e,s={}){const n=this.createNode(t,null,s),i=this.createNode(e,null,s);return new Pair(n,i)}delete(t){return!!assertCollection(this.contents)&&this.contents.delete(t)}deleteIn(t){return isEmptyPath(t)?null!=this.contents&&(this.contents=null,!0):!!assertCollection(this.contents)&&this.contents.deleteIn(t)}get(t,e){return isCollection(this.contents)?this.contents.get(t,e):void 0}getIn(t,e){return isEmptyPath(t)?!e&&isScalar(this.contents)?this.contents.value:this.contents:isCollection(this.contents)?this.contents.getIn(t,e):void 0}has(t){return!!isCollection(this.contents)&&this.contents.has(t)}hasIn(t){return isEmptyPath(t)?void 0!==this.contents:!!isCollection(this.contents)&&this.contents.hasIn(t)}set(t,e){null==this.contents?this.contents=collectionFromPath(this.schema,[t],e):assertCollection(this.contents)&&this.contents.set(t,e)}setIn(t,e){isEmptyPath(t)?this.contents=e:null==this.contents?this.contents=collectionFromPath(this.schema,Array.from(t),e):assertCollection(this.contents)&&this.contents.setIn(t,e)}setSchema(t,e={}){let s;switch("number"==typeof t&&(t=String(t)),t){case"1.1":this.directives?this.directives.yaml.version="1.1":this.directives=new Directives({version:"1.1"}),s={resolveKnownTags:!1,schema:"yaml-1.1"};break;case"1.2":case"next":this.directives?this.directives.yaml.version=t:this.directives=new Directives({version:t}),s={resolveKnownTags:!0,schema:"core"};break;case null:this.directives&&delete this.directives,s=null;break;default:{const e=JSON.stringify(t);throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${e}`)}}if(e.schema instanceof Object)this.schema=e.schema;else{if(!s)throw new Error("With a null YAML version, the { schema: Schema } option is required");this.schema=new Schema(Object.assign(s,e))}}toJS({json:t,jsonArg:e,mapAsMap:s,maxAliasCount:n,onAnchor:i,reviver:o}={}){const r={anchors:new Map,doc:this,keep:!t,mapAsMap:!0===s,mapKeyWarned:!1,maxAliasCount:"number"==typeof n?n:100},c=toJS(this.contents,e??"",r);if("function"==typeof i)for(const{count:t,res:e}of r.anchors.values())i(e,t);return"function"==typeof o?applyReviver(o,{"":c},"",c):c}toJSON(t,e){return this.toJS({json:!0,jsonArg:t,mapAsMap:!1,onAnchor:e})}toString(t={}){if(this.errors.length>0)throw new Error("Document with errors cannot be stringified");if("indent"in t&&(!Number.isInteger(t.indent)||Number(t.indent)<=0)){const e=JSON.stringify(t.indent);throw new Error(`"indent" option must be a positive integer, not ${e}`)}return stringifyDocument(this,t)}}function assertCollection(t){if(isCollection(t))return!0;throw new Error("Expected a YAML collection as document contents")}export{Document};