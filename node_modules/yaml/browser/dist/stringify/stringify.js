import{anchorIsValid}from"../doc/anchors.js";import{isPair,isAlias,isNode,isScalar,isCollection}from"../nodes/identity.js";import{stringifyComment}from"./stringifyComment.js";import{stringifyString}from"./stringifyString.js";function createStringifyContext(t,e){const i=Object.assign({blockQuote:!0,commentString:stringifyComment,defaultKeyType:null,defaultStringType:"PLAIN",directives:null,doubleQuotedAsJSON:!1,doubleQuotedMinMultiLineLength:40,falseStr:"false",flowCollectionPadding:!0,indentSeq:!0,lineWidth:80,minContentWidth:20,nullStr:"null",simpleKeys:!1,singleQuote:null,trueStr:"true",verifyAliasOrder:!0},t.schema.toStringOptions,e);let n;switch(i.collectionStyle){case"block":n=!1;break;case"flow":n=!0;break;default:n=null}return{anchors:new Set,doc:t,flowCollectionPadding:i.flowCollectionPadding?" ":"",indent:"",indentStep:"number"==typeof i.indent?" ".repeat(i.indent):"  ",inFlow:n,options:i}}function getTagObject(t,e){if(e.tag){const i=t.filter(t=>t.tag===e.tag);if(i.length>0)return i.find(t=>t.format===e.format)??i[0]}let i,n;if(isScalar(e)){n=e.value;let r=t.filter(t=>t.identify?.(n));if(r.length>1){const t=r.filter(t=>t.test);t.length>0&&(r=t)}i=r.find(t=>t.format===e.format)??r.find(t=>!t.format)}else n=e,i=t.find(t=>t.nodeClass&&n instanceof t.nodeClass);if(!i)throw new Error(`Tag not resolved for ${n?.constructor?.name??(null===n?"null":typeof n)} value`);return i}function stringifyProps(t,e,{anchors:i,doc:n}){if(!n.directives)return"";const r=[],o=(isScalar(t)||isCollection(t))&&t.anchor;o&&anchorIsValid(o)&&(i.add(o),r.push(`&${o}`));const s=t.tag??(e.default?null:e.tag);return s&&r.push(n.directives.tagString(s)),r.join(" ")}function stringify(t,e,i,n){if(isPair(t))return t.toString(e,i,n);if(isAlias(t)){if(e.doc.directives)return t.toString(e);if(e.resolvedAliases?.has(t))throw new TypeError("Cannot stringify circular structure without alias nodes");e.resolvedAliases?e.resolvedAliases.add(t):e.resolvedAliases=new Set([t]),t=t.resolve(e.doc)}let r;const o=isNode(t)?t:e.doc.createNode(t,{onTagObj:t=>r=t});r??(r=getTagObject(e.doc.schema.tags,o));const s=stringifyProps(o,r,e);s.length>0&&(e.indentAtStart=(e.indentAtStart??0)+s.length+1);const l="function"==typeof r.stringify?r.stringify(o,e,i,n):isScalar(o)?stringifyString(o,e,i,n):o.toString(e,i,n);return s?isScalar(o)||"{"===l[0]||"["===l[0]?`${s} ${l}`:`${s}\n${e.indent}${l}`:l}export{createStringifyContext,stringify};