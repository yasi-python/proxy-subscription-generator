import{anchorIsValid}from"../doc/anchors.js";import{visit}from"../visit.js";import{ALIAS,isAlias,isCollection,isPair,hasAnchor}from"./identity.js";import{NodeBase}from"./Node.js";import{toJS}from"./toJS.js";class Alias extends NodeBase{constructor(e){super(ALIAS),this.source=e,Object.defineProperty(this,"tag",{set(){throw new Error("Alias nodes cannot have tags")}})}resolve(e,s){let o,t;s?.aliasResolveCache?o=s.aliasResolveCache:(o=[],visit(e,{Node:(e,s)=>{(isAlias(s)||hasAnchor(s))&&o.push(s)}}),s&&(s.aliasResolveCache=o));for(const e of o){if(e===this)break;e.anchor===this.source&&(t=e)}return t}toJSON(e,s){if(!s)return{source:this.source};const{anchors:o,doc:t,maxAliasCount:r}=s,i=this.resolve(t,s);if(!i){const e=`Unresolved alias (the anchor must be set before the alias): ${this.source}`;throw new ReferenceError(e)}let a=o.get(i);if(a||(toJS(i,null,s),a=o.get(i)),!a||void 0===a.res)throw new ReferenceError("This should not happen: Alias anchor was not resolved?");if(r>=0&&(a.count+=1,0===a.aliasCount&&(a.aliasCount=getAliasCount(t,i,o)),a.count*a.aliasCount>r))throw new ReferenceError("Excessive alias count indicates a resource exhaustion attack");return a.res}toString(e,s,o){const t=`*${this.source}`;if(e){if(anchorIsValid(this.source),e.options.verifyAliasOrder&&!e.anchors.has(this.source)){const e=`Unresolved alias (the anchor must be set before the alias): ${this.source}`;throw new Error(e)}if(e.implicitKey)return`${t} `}return t}}function getAliasCount(e,s,o){if(isAlias(s)){const t=s.resolve(e),r=o&&t&&o.get(t);return r?r.count*r.aliasCount:0}if(isCollection(s)){let t=0;for(const r of s.items){const s=getAliasCount(e,r,o);s>t&&(t=s)}return t}if(isPair(s)){const t=getAliasCount(e,s.key,o),r=getAliasCount(e,s.value,o);return Math.max(t,r)}return 1}export{Alias};