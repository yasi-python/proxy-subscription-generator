import{Pair}from"../nodes/Pair.js";import{YAMLMap}from"../nodes/YAMLMap.js";import{resolveProps}from"./resolve-props.js";import{containsNewline}from"./util-contains-newline.js";import{flowIndentCheck}from"./util-flow-indent-check.js";import{mapIncludes}from"./util-map-includes.js";const startColMsg="All mapping items must start at the same column";function resolveBlockMap({composeNode:e,composeEmptyNode:n},t,o,s,i){const a=new(i?.nodeClass??YAMLMap)(t.schema);t.atRoot&&(t.atRoot=!1);let m=o.offset,c=null;for(const i of o.items){const{start:r,key:l,sep:p,value:d}=i,f=resolveProps(r,{indicator:"explicit-key-ind",next:l??p?.[0],offset:m,onError:s,parentIndent:o.indent,startOnNewline:!0}),u=!f.found;if(u){if(l&&("block-seq"===l.type?s(m,"BLOCK_AS_IMPLICIT_KEY","A block sequence may not be used as an implicit map key"):"indent"in l&&l.indent!==o.indent&&s(m,"BAD_INDENT",startColMsg)),!f.anchor&&!f.tag&&!p){c=f.end,f.comment&&(a.comment?a.comment+="\n"+f.comment:a.comment=f.comment);continue}(f.newlineAfterProp||containsNewline(l))&&s(l??r[r.length-1],"MULTILINE_IMPLICIT_KEY","Implicit keys need to be on a single line")}else f.found?.indent!==o.indent&&s(m,"BAD_INDENT",startColMsg);t.atKey=!0;const I=f.end,k=l?e(t,l,f,s):n(t,I,r,null,f,s);t.schema.compat&&flowIndentCheck(o.indent,l,s),t.atKey=!1,mapIncludes(t,a.items,k)&&s(I,"DUPLICATE_KEY","Map keys must be unique");const M=resolveProps(p??[],{indicator:"map-value-ind",next:d,offset:k.range[2],onError:s,parentIndent:o.indent,startOnNewline:!l||"block-scalar"===l.type});if(m=M.end,M.found){u&&("block-map"!==d?.type||M.hasNewline||s(m,"BLOCK_AS_IMPLICIT_KEY","Nested mappings are not allowed in compact mappings"),t.options.strict&&f.start<M.found.offset-1024&&s(k.range,"KEY_OVER_1024_CHARS","The : indicator must be at most 1024 chars after the start of an implicit block mapping key"));const c=d?e(t,d,M,s):n(t,m,p,null,M,s);t.schema.compat&&flowIndentCheck(o.indent,d,s),m=c.range[2];const r=new Pair(k,c);t.options.keepSourceTokens&&(r.srcToken=i),a.items.push(r)}else{u&&s(k.range,"MISSING_CHAR","Implicit map keys need to be followed by map values"),M.comment&&(k.comment?k.comment+="\n"+M.comment:k.comment=M.comment);const e=new Pair(k);t.options.keepSourceTokens&&(e.srcToken=i),a.items.push(e)}}return c&&c<m&&s(c,"IMPOSSIBLE","Map comment with trailing content"),a.range=[o.offset,m,c??m],a}export{resolveBlockMap};