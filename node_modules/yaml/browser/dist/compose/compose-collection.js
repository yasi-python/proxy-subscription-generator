import{isNode}from"../nodes/identity.js";import{Scalar}from"../nodes/Scalar.js";import{YAMLMap}from"../nodes/YAMLMap.js";import{YAMLSeq}from"../nodes/YAMLSeq.js";import{resolveBlockMap}from"./resolve-block-map.js";import{resolveBlockSeq}from"./resolve-block-seq.js";import{resolveFlowCollection}from"./resolve-flow-collection.js";function resolveCollection(e,o,t,s,l,r){const c="block-map"===t.type?resolveBlockMap(e,o,t,s,r):"block-seq"===t.type?resolveBlockSeq(e,o,t,s,r):resolveFlowCollection(e,o,t,s,r),a=c.constructor;return"!"===l||l===a.tagName?(c.tag=a.tagName,c):(l&&(c.tag=l),c)}function composeCollection(e,o,t,s,l){const r=s.tag,c=r?o.directives.tagName(r.source,e=>l(r,"TAG_RESOLVE_FAILED",e)):null;if("block-seq"===t.type){const{anchor:e,newlineAfterProp:o}=s,t=e&&r?e.offset>r.offset?e:r:e??r;if(t&&(!o||o.offset<t.offset)){l(t,"MISSING_CHAR","Missing newline after block sequence props")}}const a="block-map"===t.type?"map":"block-seq"===t.type?"seq":"{"===t.start.source?"map":"seq";if(!r||!c||"!"===c||c===YAMLMap.tagName&&"map"===a||c===YAMLSeq.tagName&&"seq"===a)return resolveCollection(e,o,t,l,c);let n=o.schema.tags.find(e=>e.tag===c&&e.collection===a);if(!n){const s=o.schema.knownTags[c];if(!s||s.collection!==a)return s?l(r,"BAD_COLLECTION_TYPE",`${s.tag} used for ${a} collection, but expects ${s.collection??"scalar"}`,!0):l(r,"TAG_RESOLVE_FAILED",`Unresolved tag: ${c}`,!0),resolveCollection(e,o,t,l,c);o.schema.tags.push(Object.assign({},s,{default:!1})),n=s}const i=resolveCollection(e,o,t,l,c,n),m=n.resolve?.(i,e=>l(r,"TAG_RESOLVE_FAILED",e),o.options)??i,p=isNode(m)?m:new Scalar(m);return p.range=i.range,p.tag=c,n?.format&&(p.format=n.format),p}export{composeCollection};