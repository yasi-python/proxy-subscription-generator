import{isPair}from"../nodes/identity.js";import{Pair}from"../nodes/Pair.js";import{YAMLMap}from"../nodes/YAMLMap.js";import{YAMLSeq}from"../nodes/YAMLSeq.js";import{resolveEnd}from"./resolve-end.js";import{resolveProps}from"./resolve-props.js";import{containsNewline}from"./util-contains-newline.js";import{mapIncludes}from"./util-map-includes.js";const blockMsg="Block collections are not allowed within flow collections",isBlock=e=>e&&("block-map"===e.type||"block-seq"===e.type);function resolveFlowCollection({composeNode:e,composeEmptyNode:o},n,t,s,i){const c="{"===t.start.source,m=c?"flow map":"flow sequence",r=new(i?.nodeClass??(c?YAMLMap:YAMLSeq))(n.schema);r.flow=!0;const l=n.atRoot;l&&(n.atRoot=!1),n.atKey&&(n.atKey=!1);let a=t.offset+t.start.source.length;for(let i=0;i<t.items.length;++i){const l=t.items[i],{start:f,key:p,sep:u,value:d}=l,g=resolveProps(f,{flow:m,indicator:"explicit-key-ind",next:p??u?.[0],offset:a,onError:s,parentIndent:t.indent,startOnNewline:!1});if(!g.found){if(!(g.anchor||g.tag||u||d)){0===i&&g.comma?s(g.comma,"UNEXPECTED_TOKEN",`Unexpected , in ${m}`):i<t.items.length-1&&s(g.start,"UNEXPECTED_TOKEN",`Unexpected empty item in ${m}`),g.comment&&(r.comment?r.comment+="\n"+g.comment:r.comment=g.comment),a=g.end;continue}!c&&n.options.strict&&containsNewline(p)&&s(p,"MULTILINE_IMPLICIT_KEY","Implicit keys of flow sequence pairs need to be on a single line")}if(0===i)g.comma&&s(g.comma,"UNEXPECTED_TOKEN",`Unexpected , in ${m}`);else if(g.comma||s(g.start,"MISSING_CHAR",`Missing , between ${m} items`),g.comment){let e="";e:for(const o of f)switch(o.type){case"comma":case"space":break;case"comment":e=o.source.substring(1);break e;default:break e}if(e){let o=r.items[r.items.length-1];isPair(o)&&(o=o.value??o.key),o.comment?o.comment+="\n"+e:o.comment=e,g.comment=g.comment.substring(e.length+1)}}if(c||u||g.found){n.atKey=!0;const i=g.end,I=p?e(n,p,g,s):o(n,i,f,null,g,s);isBlock(p)&&s(I.range,"BLOCK_IN_FLOW",blockMsg),n.atKey=!1;const w=resolveProps(u??[],{flow:m,indicator:"map-value-ind",next:d,offset:I.range[2],onError:s,parentIndent:t.indent,startOnNewline:!1});if(w.found){if(!c&&!g.found&&n.options.strict){if(u)for(const e of u){if(e===w.found)break;if("newline"===e.type){s(e,"MULTILINE_IMPLICIT_KEY","Implicit keys of flow sequence pairs need to be on a single line");break}}g.start<w.found.offset-1024&&s(w.found,"KEY_OVER_1024_CHARS","The : indicator must be at most 1024 chars after the start of an implicit flow sequence key")}}else d&&("source"in d&&d.source&&":"===d.source[0]?s(d,"MISSING_CHAR",`Missing space after : in ${m}`):s(w.start,"MISSING_CHAR",`Missing , or : between ${m} items`));const k=d?e(n,d,w,s):w.found?o(n,w.end,u,null,w,s):null;k?isBlock(d)&&s(k.range,"BLOCK_IN_FLOW",blockMsg):w.comment&&(I.comment?I.comment+="\n"+w.comment:I.comment=w.comment);const M=new Pair(I,k);if(n.options.keepSourceTokens&&(M.srcToken=l),c){const e=r;mapIncludes(n,e.items,I)&&s(i,"DUPLICATE_KEY","Map keys must be unique"),e.items.push(M)}else{const e=new YAMLMap(n.schema);e.flow=!0,e.items.push(M);const o=(k??I).range;e.range=[I.range[0],o[1],o[2]],r.items.push(e)}a=k?k.range[2]:w.end}else{const t=d?e(n,d,g,s):o(n,g.end,u,null,g,s);r.items.push(t),a=t.range[2],isBlock(d)&&s(t.range,"BLOCK_IN_FLOW",blockMsg)}}const f=c?"}":"]",[p,...u]=t.end;let d=a;if(p&&p.source===f)d=p.offset+p.source.length;else{const e=m[0].toUpperCase()+m.substring(1);s(a,l?"MISSING_CHAR":"BAD_INDENT",l?`${e} must end with a ${f}`:`${e} in block collection must be sufficiently indented and end with a ${f}`),p&&1!==p.source.length&&u.unshift(p)}if(u.length>0){const e=resolveEnd(u,d,n.options.strict,s);e.comment&&(r.comment?r.comment+="\n"+e.comment:r.comment=e.comment),r.range=[t.offset,d,e.offset]}else r.range=[t.offset,d,d];return r}export{resolveFlowCollection};