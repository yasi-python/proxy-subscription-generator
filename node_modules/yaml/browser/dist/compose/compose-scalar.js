import{isScalar,SCALAR}from"../nodes/identity.js";import{Scalar}from"../nodes/Scalar.js";import{resolveBlockScalar}from"./resolve-block-scalar.js";import{resolveFlowScalar}from"./resolve-flow-scalar.js";function composeScalar(t,a,e,r){const{value:o,type:s,comment:c,range:n}="block-scalar"===a.type?resolveBlockScalar(t,a,r):resolveFlowScalar(a,t.options.strict,r),l=e?t.directives.tagName(e.source,t=>r(e,"TAG_RESOLVE_FAILED",t)):null;let i,f;i=t.options.stringKeys&&t.atKey?t.schema[SCALAR]:l?findScalarTagByName(t.schema,o,l,e,r):"scalar"===a.type?findScalarTagByTest(t,o,a,r):t.schema[SCALAR];try{const s=i.resolve(o,t=>r(e??a,"TAG_RESOLVE_FAILED",t),t.options);f=isScalar(s)?s:new Scalar(s)}catch(t){const s=t instanceof Error?t.message:String(t);r(e??a,"TAG_RESOLVE_FAILED",s),f=new Scalar(o)}return f.range=n,f.source=o,s&&(f.type=s),l&&(f.tag=l),i.format&&(f.format=i.format),c&&(f.comment=c),f}function findScalarTagByName(t,a,e,r,o){if("!"===e)return t[SCALAR];const s=[];for(const a of t.tags)if(!a.collection&&a.tag===e){if(!a.default||!a.test)return a;s.push(a)}for(const t of s)if(t.test?.test(a))return t;const c=t.knownTags[e];return c&&!c.collection?(t.tags.push(Object.assign({},c,{default:!1,test:void 0})),c):(o(r,"TAG_RESOLVE_FAILED",`Unresolved tag: ${e}`,"tag:yaml.org,2002:str"!==e),t[SCALAR])}function findScalarTagByTest({atKey:t,directives:a,schema:e},r,o,s){const c=e.tags.find(a=>(!0===a.default||t&&"key"===a.default)&&a.test?.test(r))||e[SCALAR];if(e.compat){const t=e.compat.find(t=>t.default&&t.test?.test(r))??e[SCALAR];c.tag!==t.tag&&s(o,"TAG_RESOLVE_FAILED",`Value may be parsed as either ${a.tagString(c.tag)} or ${a.tagString(t.tag)}`,!0)}return c}export{composeScalar};