import{Scalar}from"../nodes/Scalar.js";function resolveBlockScalar(e,t,n){const l=t.offset,c=parseBlockScalarHeader(t,e.options.strict,n);if(!c)return{value:"",type:null,comment:"",range:[l,l,l]};const r=">"===c.mode?Scalar.BLOCK_FOLDED:Scalar.BLOCK_LITERAL,o=t.source?splitLines(t.source):[];let s=o.length;for(let e=o.length-1;e>=0;--e){const t=o[e][1];if(""!==t&&"\r"!==t)break;s=e}if(0===s){const e="+"===c.chomp&&o.length>0?"\n".repeat(Math.max(1,o.length-1)):"";let n=l+c.length;return t.source&&(n+=t.source.length),{value:e,type:r,comment:c.comment,range:[l,n,n]}}let a=t.indent+c.indent,i=t.offset+c.length,h=0;for(let t=0;t<s;++t){const[l,r]=o[t];if(""!==r&&"\r"!==r){if(l.length<a){const e="Block scalars with more-indented leading empty lines must use an explicit indentation indicator";n(i+l.length,"MISSING_CHAR",e)}if(0===c.indent&&(a=l.length),h=t,0===a&&!e.atRoot){n(i,"BAD_INDENT","Block scalar values in collections must be indented")}break}0===c.indent&&l.length>a&&(a=l.length),i+=l.length+r.length+1}for(let e=o.length-1;e>=s;--e)o[e][0].length>a&&(s=e+1);let g="",u="",f=!1;for(let e=0;e<h;++e)g+=o[e][0].slice(a)+"\n";for(let e=h;e<s;++e){let[t,l]=o[e];i+=t.length+l.length+1;const s="\r"===l[l.length-1];if(s&&(l=l.slice(0,-1)),l&&t.length<a){const e=`Block scalar lines must not be less indented than their ${c.indent?"explicit indentation indicator":"first line"}`;n(i-l.length-(s?2:1),"BAD_INDENT",e),t=""}r===Scalar.BLOCK_LITERAL?(g+=u+t.slice(a)+l,u="\n"):t.length>a||"\t"===l[0]?(" "===u?u="\n":f||"\n"!==u||(u="\n\n"),g+=u+t.slice(a)+l,u="\n",f=!0):""===l?"\n"===u?g+="\n":u="\n":(g+=u+l,u=" ",f=!1)}switch(c.chomp){case"-":break;case"+":for(let e=s;e<o.length;++e)g+="\n"+o[e][0].slice(a);"\n"!==g[g.length-1]&&(g+="\n");break;default:g+="\n"}const m=l+c.length+t.source.length;return{value:g,type:r,comment:c.comment,range:[l,m,m]}}function parseBlockScalarHeader({offset:e,props:t},n,l){if("block-scalar-header"!==t[0].type)return l(t[0],"IMPOSSIBLE","Block scalar header not found"),null;const{source:c}=t[0],r=c[0];let o=0,s="",a=-1;for(let t=1;t<c.length;++t){const n=c[t];if(s||"-"!==n&&"+"!==n){const l=Number(n);!o&&l?o=l:-1===a&&(a=e+t)}else s=n}-1!==a&&l(a,"UNEXPECTED_TOKEN",`Block scalar header includes extra characters: ${c}`);let i=!1,h="",g=c.length;for(let e=1;e<t.length;++e){const c=t[e];switch(c.type){case"space":i=!0;case"newline":g+=c.source.length;break;case"comment":if(n&&!i){l(c,"MISSING_CHAR","Comments must be separated from other tokens by white space characters")}g+=c.source.length,h=c.source.substring(1);break;case"error":l(c,"UNEXPECTED_TOKEN",c.message),g+=c.source.length;break;default:{l(c,"UNEXPECTED_TOKEN",`Unexpected token in block scalar header: ${c.type}`);const e=c.source;e&&"string"==typeof e&&(g+=e.length)}}}return{mode:r,indent:o,chomp:s,comment:h,length:g}}function splitLines(e){const t=e.split(/\n( *)/),n=t[0],l=n.match(/^( *)/),c=[l?.[1]?[l[1],n.slice(l[1].length)]:["",n]];for(let e=1;e<t.length;e+=2)c.push([t[e],t[e+1]]);return c}export{resolveBlockScalar};