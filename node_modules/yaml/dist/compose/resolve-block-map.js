"use strict";var Pair=require("../nodes/Pair.js"),YAMLMap=require("../nodes/YAMLMap.js"),resolveProps=require("./resolve-props.js"),utilContainsNewline=require("./util-contains-newline.js"),utilFlowIndentCheck=require("./util-flow-indent-check.js"),utilMapIncludes=require("./util-map-includes.js");const startColMsg="All mapping items must start at the same column";function resolveBlockMap({composeNode:e,composeEmptyNode:n},t,o,s,i){const a=new(i?.nodeClass??YAMLMap.YAMLMap)(t.schema);t.atRoot&&(t.atRoot=!1);let l=o.offset,r=null;for(const i of o.items){const{start:c,key:m,sep:p,value:u}=i,d=resolveProps.resolveProps(c,{indicator:"explicit-key-ind",next:m??p?.[0],offset:l,onError:s,parentIndent:o.indent,startOnNewline:!0}),I=!d.found;if(I){if(m&&("block-seq"===m.type?s(l,"BLOCK_AS_IMPLICIT_KEY","A block sequence may not be used as an implicit map key"):"indent"in m&&m.indent!==o.indent&&s(l,"BAD_INDENT",startColMsg)),!d.anchor&&!d.tag&&!p){r=d.end,d.comment&&(a.comment?a.comment+="\n"+d.comment:a.comment=d.comment);continue}(d.newlineAfterProp||utilContainsNewline.containsNewline(m))&&s(m??c[c.length-1],"MULTILINE_IMPLICIT_KEY","Implicit keys need to be on a single line")}else d.found?.indent!==o.indent&&s(l,"BAD_INDENT",startColMsg);t.atKey=!0;const f=d.end,k=m?e(t,m,d,s):n(t,f,c,null,d,s);t.schema.compat&&utilFlowIndentCheck.flowIndentCheck(o.indent,m,s),t.atKey=!1,utilMapIncludes.mapIncludes(t,a.items,k)&&s(f,"DUPLICATE_KEY","Map keys must be unique");const M=resolveProps.resolveProps(p??[],{indicator:"map-value-ind",next:u,offset:k.range[2],onError:s,parentIndent:o.indent,startOnNewline:!m||"block-scalar"===m.type});if(l=M.end,M.found){I&&("block-map"!==u?.type||M.hasNewline||s(l,"BLOCK_AS_IMPLICIT_KEY","Nested mappings are not allowed in compact mappings"),t.options.strict&&d.start<M.found.offset-1024&&s(k.range,"KEY_OVER_1024_CHARS","The : indicator must be at most 1024 chars after the start of an implicit block mapping key"));const r=u?e(t,u,M,s):n(t,l,p,null,M,s);t.schema.compat&&utilFlowIndentCheck.flowIndentCheck(o.indent,u,s),l=r.range[2];const c=new Pair.Pair(k,r);t.options.keepSourceTokens&&(c.srcToken=i),a.items.push(c)}else{I&&s(k.range,"MISSING_CHAR","Implicit map keys need to be followed by map values"),M.comment&&(k.comment?k.comment+="\n"+M.comment:k.comment=M.comment);const e=new Pair.Pair(k);t.options.keepSourceTokens&&(e.srcToken=i),a.items.push(e)}}return r&&r<l&&s(r,"IMPOSSIBLE","Map comment with trailing content"),a.range=[o.offset,l,r??l],a}exports.resolveBlockMap=resolveBlockMap;