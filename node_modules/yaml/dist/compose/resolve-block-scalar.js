"use strict";var Scalar=require("../nodes/Scalar.js");function resolveBlockScalar(e,t,n){const l=t.offset,r=parseBlockScalarHeader(t,e.options.strict,n);if(!r)return{value:"",type:null,comment:"",range:[l,l,l]};const c=">"===r.mode?Scalar.Scalar.BLOCK_FOLDED:Scalar.Scalar.BLOCK_LITERAL,s=t.source?splitLines(t.source):[];let a=s.length;for(let e=s.length-1;e>=0;--e){const t=s[e][1];if(""!==t&&"\r"!==t)break;a=e}if(0===a){const e="+"===r.chomp&&s.length>0?"\n".repeat(Math.max(1,s.length-1)):"";let n=l+r.length;return t.source&&(n+=t.source.length),{value:e,type:c,comment:r.comment,range:[l,n,n]}}let o=t.indent+r.indent,i=t.offset+r.length,h=0;for(let t=0;t<a;++t){const[l,c]=s[t];if(""!==c&&"\r"!==c){if(l.length<o){const e="Block scalars with more-indented leading empty lines must use an explicit indentation indicator";n(i+l.length,"MISSING_CHAR",e)}0===r.indent&&(o=l.length),h=t,0!==o||e.atRoot||n(i,"BAD_INDENT","Block scalar values in collections must be indented");break}0===r.indent&&l.length>o&&(o=l.length),i+=l.length+c.length+1}for(let e=s.length-1;e>=a;--e)s[e][0].length>o&&(a=e+1);let g="",u="",d=!1;for(let e=0;e<h;++e)g+=s[e][0].slice(o)+"\n";for(let e=h;e<a;++e){let[t,l]=s[e];i+=t.length+l.length+1;const a="\r"===l[l.length-1];if(a&&(l=l.slice(0,-1)),l&&t.length<o){const e="Block scalar lines must not be less indented than their "+(r.indent?"explicit indentation indicator":"first line");n(i-l.length-(a?2:1),"BAD_INDENT",e),t=""}c===Scalar.Scalar.BLOCK_LITERAL?(g+=u+t.slice(o)+l,u="\n"):t.length>o||"\t"===l[0]?(" "===u?u="\n":d||"\n"!==u||(u="\n\n"),g+=u+t.slice(o)+l,u="\n",d=!0):""===l?"\n"===u?g+="\n":u="\n":(g+=u+l,u=" ",d=!1)}switch(r.chomp){case"-":break;case"+":for(let e=a;e<s.length;++e)g+="\n"+s[e][0].slice(o);"\n"!==g[g.length-1]&&(g+="\n");break;default:g+="\n"}const f=l+r.length+t.source.length;return{value:g,type:c,comment:r.comment,range:[l,f,f]}}function parseBlockScalarHeader({offset:e,props:t},n,l){if("block-scalar-header"!==t[0].type)return l(t[0],"IMPOSSIBLE","Block scalar header not found"),null;const{source:r}=t[0],c=r[0];let s=0,a="",o=-1;for(let t=1;t<r.length;++t){const n=r[t];if(a||"-"!==n&&"+"!==n){const l=Number(n);!s&&l?s=l:-1===o&&(o=e+t)}else a=n}-1!==o&&l(o,"UNEXPECTED_TOKEN",`Block scalar header includes extra characters: ${r}`);let i=!1,h="",g=r.length;for(let e=1;e<t.length;++e){const r=t[e];switch(r.type){case"space":i=!0;case"newline":g+=r.source.length;break;case"comment":n&&!i&&l(r,"MISSING_CHAR","Comments must be separated from other tokens by white space characters"),g+=r.source.length,h=r.source.substring(1);break;case"error":l(r,"UNEXPECTED_TOKEN",r.message),g+=r.source.length;break;default:{l(r,"UNEXPECTED_TOKEN",`Unexpected token in block scalar header: ${r.type}`);const e=r.source;e&&"string"==typeof e&&(g+=e.length)}}}return{mode:c,indent:s,chomp:a,comment:h,length:g}}function splitLines(e){const t=e.split(/\n( *)/),n=t[0],l=n.match(/^( *)/),r=[l?.[1]?[l[1],n.slice(l[1].length)]:["",n]];for(let e=1;e<t.length;e+=2)r.push([t[e],t[e+1]]);return r}exports.resolveBlockScalar=resolveBlockScalar;