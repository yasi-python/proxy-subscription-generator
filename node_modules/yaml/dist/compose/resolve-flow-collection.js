"use strict";var identity=require("../nodes/identity.js"),Pair=require("../nodes/Pair.js"),YAMLMap=require("../nodes/YAMLMap.js"),YAMLSeq=require("../nodes/YAMLSeq.js"),resolveEnd=require("./resolve-end.js"),resolveProps=require("./resolve-props.js"),utilContainsNewline=require("./util-contains-newline.js"),utilMapIncludes=require("./util-map-includes.js");const blockMsg="Block collections are not allowed within flow collections",isBlock=e=>e&&("block-map"===e.type||"block-seq"===e.type);function resolveFlowCollection({composeNode:e,composeEmptyNode:n},t,o,s,i){const c="{"===o.start.source,r=c?"flow map":"flow sequence",l=new(i?.nodeClass??(c?YAMLMap.YAMLMap:YAMLSeq.YAMLSeq))(t.schema);l.flow=!0;const a=t.atRoot;a&&(t.atRoot=!1),t.atKey&&(t.atKey=!1);let m=o.offset+o.start.source.length;for(let i=0;i<o.items.length;++i){const a=o.items[i],{start:u,key:f,sep:p,value:d}=a,M=resolveProps.resolveProps(u,{flow:r,indicator:"explicit-key-ind",next:f??p?.[0],offset:m,onError:s,parentIndent:o.indent,startOnNewline:!1});if(!M.found){if(!(M.anchor||M.tag||p||d)){0===i&&M.comma?s(M.comma,"UNEXPECTED_TOKEN",`Unexpected , in ${r}`):i<o.items.length-1&&s(M.start,"UNEXPECTED_TOKEN",`Unexpected empty item in ${r}`),M.comment&&(l.comment?l.comment+="\n"+M.comment:l.comment=M.comment),m=M.end;continue}!c&&t.options.strict&&utilContainsNewline.containsNewline(f)&&s(f,"MULTILINE_IMPLICIT_KEY","Implicit keys of flow sequence pairs need to be on a single line")}if(0===i)M.comma&&s(M.comma,"UNEXPECTED_TOKEN",`Unexpected , in ${r}`);else if(M.comma||s(M.start,"MISSING_CHAR",`Missing , between ${r} items`),M.comment){let e="";e:for(const n of u)switch(n.type){case"comma":case"space":break;case"comment":e=n.source.substring(1);break e;default:break e}if(e){let n=l.items[l.items.length-1];identity.isPair(n)&&(n=n.value??n.key),n.comment?n.comment+="\n"+e:n.comment=e,M.comment=M.comment.substring(e.length+1)}}if(c||p||M.found){t.atKey=!0;const i=M.end,g=f?e(t,f,M,s):n(t,i,u,null,M,s);isBlock(f)&&s(g.range,"BLOCK_IN_FLOW",blockMsg),t.atKey=!1;const w=resolveProps.resolveProps(p??[],{flow:r,indicator:"map-value-ind",next:d,offset:g.range[2],onError:s,parentIndent:o.indent,startOnNewline:!1});if(w.found){if(!c&&!M.found&&t.options.strict){if(p)for(const e of p){if(e===w.found)break;if("newline"===e.type){s(e,"MULTILINE_IMPLICIT_KEY","Implicit keys of flow sequence pairs need to be on a single line");break}}M.start<w.found.offset-1024&&s(w.found,"KEY_OVER_1024_CHARS","The : indicator must be at most 1024 chars after the start of an implicit flow sequence key")}}else d&&("source"in d&&d.source&&":"===d.source[0]?s(d,"MISSING_CHAR",`Missing space after : in ${r}`):s(w.start,"MISSING_CHAR",`Missing , or : between ${r} items`));const I=d?e(t,d,w,s):w.found?n(t,w.end,p,null,w,s):null;I?isBlock(d)&&s(I.range,"BLOCK_IN_FLOW",blockMsg):w.comment&&(g.comment?g.comment+="\n"+w.comment:g.comment=w.comment);const k=new Pair.Pair(g,I);if(t.options.keepSourceTokens&&(k.srcToken=a),c){const e=l;utilMapIncludes.mapIncludes(t,e.items,g)&&s(i,"DUPLICATE_KEY","Map keys must be unique"),e.items.push(k)}else{const e=new YAMLMap.YAMLMap(t.schema);e.flow=!0,e.items.push(k);const n=(I??g).range;e.range=[g.range[0],n[1],n[2]],l.items.push(e)}m=I?I.range[2]:w.end}else{const o=d?e(t,d,M,s):n(t,M.end,p,null,M,s);l.items.push(o),m=o.range[2],isBlock(d)&&s(o.range,"BLOCK_IN_FLOW",blockMsg)}}const u=c?"}":"]",[f,...p]=o.end;let d=m;if(f&&f.source===u)d=f.offset+f.source.length;else{const e=r[0].toUpperCase()+r.substring(1);s(m,a?"MISSING_CHAR":"BAD_INDENT",a?`${e} must end with a ${u}`:`${e} in block collection must be sufficiently indented and end with a ${u}`),f&&1!==f.source.length&&p.unshift(f)}if(p.length>0){const e=resolveEnd.resolveEnd(p,d,t.options.strict,s);e.comment&&(l.comment?l.comment+="\n"+e.comment:l.comment=e.comment),l.range=[o.offset,d,e.offset]}else l.range=[o.offset,d,d];return l}exports.resolveFlowCollection=resolveFlowCollection;