"use strict";var anchors=require("../doc/anchors.js"),visit=require("../visit.js"),identity=require("./identity.js"),Node=require("./Node.js"),toJS=require("./toJS.js");class Alias extends Node.NodeBase{constructor(e){super(identity.ALIAS),this.source=e,Object.defineProperty(this,"tag",{set(){throw new Error("Alias nodes cannot have tags")}})}resolve(e,t){let s,i;t?.aliasResolveCache?s=t.aliasResolveCache:(s=[],visit.visit(e,{Node:(e,t)=>{(identity.isAlias(t)||identity.hasAnchor(t))&&s.push(t)}}),t&&(t.aliasResolveCache=s));for(const e of s){if(e===this)break;e.anchor===this.source&&(i=e)}return i}toJSON(e,t){if(!t)return{source:this.source};const{anchors:s,doc:i,maxAliasCount:r}=t,o=this.resolve(i,t);if(!o){const e=`Unresolved alias (the anchor must be set before the alias): ${this.source}`;throw new ReferenceError(e)}let n=s.get(o);if(n||(toJS.toJS(o,null,t),n=s.get(o)),!n||void 0===n.res){throw new ReferenceError("This should not happen: Alias anchor was not resolved?")}if(r>=0&&(n.count+=1,0===n.aliasCount&&(n.aliasCount=getAliasCount(i,o,s)),n.count*n.aliasCount>r)){throw new ReferenceError("Excessive alias count indicates a resource exhaustion attack")}return n.res}toString(e,t,s){const i=`*${this.source}`;if(e){if(anchors.anchorIsValid(this.source),e.options.verifyAliasOrder&&!e.anchors.has(this.source)){const e=`Unresolved alias (the anchor must be set before the alias): ${this.source}`;throw new Error(e)}if(e.implicitKey)return`${i} `}return i}}function getAliasCount(e,t,s){if(identity.isAlias(t)){const i=t.resolve(e),r=s&&i&&s.get(i);return r?r.count*r.aliasCount:0}if(identity.isCollection(t)){let i=0;for(const r of t.items){const t=getAliasCount(e,r,s);t>i&&(i=t)}return i}if(identity.isPair(t)){const i=getAliasCount(e,t.key,s),r=getAliasCount(e,t.value,s);return Math.max(i,r)}return 1}exports.Alias=Alias;