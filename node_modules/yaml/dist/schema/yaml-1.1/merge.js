"use strict";var identity=require("../../nodes/identity.js"),Scalar=require("../../nodes/Scalar.js");const MERGE_KEY="<<",merge={identify:e=>"<<"===e||"symbol"==typeof e&&"<<"===e.description,default:"key",tag:"tag:yaml.org,2002:merge",test:/^<<$/,resolve:()=>Object.assign(new Scalar.Scalar(Symbol("<<")),{addToJSMap:addMergeToJSMap}),stringify:()=>"<<"},isMergeKey=(e,r)=>(merge.identify(r)||identity.isScalar(r)&&(!r.type||r.type===Scalar.Scalar.PLAIN)&&merge.identify(r.value))&&e?.doc.schema.tags.some(e=>e.tag===merge.tag&&e.default);function addMergeToJSMap(e,r,a){if(a=e&&identity.isAlias(a)?a.resolve(e.doc):a,identity.isSeq(a))for(const t of a.items)mergeValue(e,r,t);else if(Array.isArray(a))for(const t of a)mergeValue(e,r,t);else mergeValue(e,r,a)}function mergeValue(e,r,a){const t=e&&identity.isAlias(a)?a.resolve(e.doc):a;if(!identity.isMap(t))throw new Error("Merge sources must be maps or map aliases");const s=t.toJSON(null,e,Map);for(const[e,a]of s)r instanceof Map?r.has(e)||r.set(e,a):r instanceof Set?r.add(e):Object.prototype.hasOwnProperty.call(r,e)||Object.defineProperty(r,e,{value:a,writable:!0,enumerable:!0,configurable:!0});return r}exports.addMergeToJSMap=addMergeToJSMap,exports.isMergeKey=isMergeKey,exports.merge=merge;