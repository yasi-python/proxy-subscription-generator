"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const picomatch=require("picomatch"),normalizePath=require("normalize-path"),BANG="!",DEFAULT_OPTIONS={returnIndex:!1},arrify=t=>Array.isArray(t)?t:[t],createPattern=(t,r)=>{if("function"==typeof t)return t;if("string"==typeof t){const e=picomatch(t,r);return r=>t===r||e(r)}return t instanceof RegExp?r=>t.test(r):t=>!1},matchPatterns=(t,r,e,n)=>{const a=Array.isArray(e),o=a?e[0]:e;if(!a&&"string"!=typeof o)throw new TypeError("anymatch: second argument must be a string: got "+Object.prototype.toString.call(o));const c=normalizePath(o,!1);for(let t=0;t<r.length;t++)if((0,r[t])(c))return!!n&&-1;const i=a&&[c].concat(e.slice(1));for(let r=0;r<t.length;r++){const e=t[r];if(a?e(...i):e(c))return!n||r}return!!n&&-1},anymatch=(t,r,e=DEFAULT_OPTIONS)=>{if(null==t)throw new TypeError("anymatch: specify first argument");const n="boolean"==typeof e?{returnIndex:e}:e,a=n.returnIndex||!1,o=arrify(t),c=o.filter(t=>"string"==typeof t&&"!"===t.charAt(0)).map(t=>t.slice(1)).map(t=>picomatch(t,n)),i=o.filter(t=>"string"!=typeof t||"string"==typeof t&&"!"!==t.charAt(0)).map(t=>createPattern(t,n));return null==r?(t,r=!1)=>matchPatterns(i,c,t,"boolean"==typeof r&&r):matchPatterns(i,c,r,a)};anymatch.default=anymatch,module.exports=anymatch;