const posixClasses={"[:alnum:]":["\\p{L}\\p{Nl}\\p{Nd}",!0],"[:alpha:]":["\\p{L}\\p{Nl}",!0],"[:ascii:]":["\\x00-\\x7f",!1],"[:blank:]":["\\p{Zs}\\t",!0],"[:cntrl:]":["\\p{Cc}",!0],"[:digit:]":["\\p{Nd}",!0],"[:graph:]":["\\p{Z}\\p{C}",!0,!0],"[:lower:]":["\\p{Ll}",!0],"[:print:]":["\\p{C}",!0],"[:punct:]":["\\p{P}",!0],"[:space:]":["\\p{Z}\\t\\r\\n\\v\\f",!0],"[:upper:]":["\\p{Lu}",!0],"[:word:]":["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}",!0],"[:xdigit:]":["A-Fa-f0-9",!1]},braceEscape=e=>e.replace(/[[\]\\-]/g,"\\$&"),regexpEscape=e=>e.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&"),rangesToString=e=>e.join("");export const parseClass=(e,t)=>{const s=t;if("["!==e.charAt(s))throw new Error("not in a brace expression");const r=[],p=[];let n=s+1,a=!1,c=!1,i=!1,l=!1,h=s,g="";e:for(;n<e.length;){const t=e.charAt(n);if("!"!==t&&"^"!==t||n!==s+1){if("]"===t&&a&&!i){h=n+1;break}if(a=!0,"\\"!==t||i){if("["===t&&!i)for(const[t,[a,i,l]]of Object.entries(posixClasses))if(e.startsWith(t,n)){if(g)return["$.",!1,e.length-s,!0];n+=t.length,l?p.push(a):r.push(a),c=c||i;continue e}i=!1,g?(t>g?r.push(braceEscape(g)+"-"+braceEscape(t)):t===g&&r.push(braceEscape(t)),g="",n++):e.startsWith("-]",n+1)?(r.push(braceEscape(t+"-")),n+=2):e.startsWith("-",n+1)?(g=t,n+=2):(r.push(braceEscape(t)),n++)}else i=!0,n++}else l=!0,n++}if(h<n)return["",!1,0,!1];if(!r.length&&!p.length)return["$.",!1,e.length-s,!0];if(0===p.length&&1===r.length&&/^\\?.$/.test(r[0])&&!l){const e=2===r[0].length?r[0].slice(-1):r[0];return[regexpEscape(e),!1,h-s,!1]}const o="["+(l?"^":"")+rangesToString(r)+"]",f="["+(l?"":"^")+rangesToString(p)+"]";return[r.length&&p.length?"("+o+"|"+f+")":r.length?o:f,c,h-s,!0]};