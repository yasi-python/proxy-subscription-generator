"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.parseClass=void 0;const posixClasses={"[:alnum:]":["\\p{L}\\p{Nl}\\p{Nd}",!0],"[:alpha:]":["\\p{L}\\p{Nl}",!0],"[:ascii:]":["\\x00-\\x7f",!1],"[:blank:]":["\\p{Zs}\\t",!0],"[:cntrl:]":["\\p{Cc}",!0],"[:digit:]":["\\p{Nd}",!0],"[:graph:]":["\\p{Z}\\p{C}",!0,!0],"[:lower:]":["\\p{Ll}",!0],"[:print:]":["\\p{C}",!0],"[:punct:]":["\\p{P}",!0],"[:space:]":["\\p{Z}\\t\\r\\n\\v\\f",!0],"[:upper:]":["\\p{Lu}",!0],"[:word:]":["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}",!0],"[:xdigit:]":["A-Fa-f0-9",!1]},braceEscape=e=>e.replace(/[[\]\\-]/g,"\\$&"),regexpEscape=e=>e.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&"),rangesToString=e=>e.join(""),parseClass=(e,s)=>{const t=s;if("["!==e.charAt(t))throw new Error("not in a brace expression");const r=[],p=[];let a=t+1,n=!1,c=!1,l=!1,i=!1,o=t,h="";e:for(;a<e.length;){const s=e.charAt(a);if("!"!==s&&"^"!==s||a!==t+1){if("]"===s&&n&&!l){o=a+1;break}if(n=!0,"\\"!==s||l){if("["===s&&!l)for(const[s,[n,l,i]]of Object.entries(posixClasses))if(e.startsWith(s,a)){if(h)return["$.",!1,e.length-t,!0];a+=s.length,i?p.push(n):r.push(n),c=c||l;continue e}l=!1,h?(s>h?r.push(braceEscape(h)+"-"+braceEscape(s)):s===h&&r.push(braceEscape(s)),h="",a++):e.startsWith("-]",a+1)?(r.push(braceEscape(s+"-")),a+=2):e.startsWith("-",a+1)?(h=s,a+=2):(r.push(braceEscape(s)),a++)}else l=!0,a++}else i=!0,a++}if(o<a)return["",!1,0,!1];if(!r.length&&!p.length)return["$.",!1,e.length-t,!0];if(0===p.length&&1===r.length&&/^\\?.$/.test(r[0])&&!i){const e=2===r[0].length?r[0].slice(-1):r[0];return[regexpEscape(e),!1,o-t,!1]}const g="["+(i?"^":"")+rangesToString(r)+"]",u="["+(i?"":"^")+rangesToString(p)+"]";return[r.length&&p.length?"("+g+"|"+u+")":r.length?g:u,c,o-t,!0]};exports.parseClass=parseClass;