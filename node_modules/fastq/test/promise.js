"use strict";const test=require("tape"),buildQueue=require("../").promise,{promisify:promisify}=require("util"),sleep=promisify(setTimeout),immediate=promisify(setImmediate);test("concurrency",function(e){async function n(e){return!0}e.plan(2),e.throws(buildQueue.bind(null,n,0)),e.doesNotThrow(buildQueue.bind(null,n,1))}),test("worker execution",async function(e){const n=buildQueue(async function(n){return e.equal(n,42),!0},1),t=await n.push(42);e.equal(t,!0,"result matches")}),test("limit",async function(e){const n=buildQueue(async function(e){return await sleep(e),e},1),[t,s]=await Promise.all([n.push(10),n.push(0)]);e.equal(t,10,"the result matches"),e.equal(s,0,"the result matches")}),test("multiple executions",async function(e){const n=buildQueue(async function(n){return e.equal(n,t[i],"arg matches"),s[i++]},1),t=[1,2,3,4,5],s=["a","b","c","d","e"];let i=0;await Promise.all(t.map(async function(t,i){const a=await n.push(t);e.equal(a,s[i],"the result matches")}))}),test("drained",async function(e){const n=buildQueue(async function(e){await sleep(e),s++},2),t=new Array(10).fill(10);let s=0;t.forEach(function(e){n.push(e)}),await n.drained(),e.equal(s,t.length),t.forEach(function(e){n.push(e)}),await n.drained(),e.equal(s,2*t.length)}),test("drained with exception should not throw",async function(e){const n=buildQueue(async function(){throw new Error("foo")},2);new Array(10).fill(10).forEach(function(e){n.push(e)}),await n.drained()}),test("drained with drain function",async function(e){let n=!1;const t=buildQueue(async function(e){await sleep(e),i++},2);t.drain=function(){n=!0};const s=new Array(10).fill(10);let i=0;s.forEach(function(){t.push()}),await t.drained(),e.equal(i,s.length),e.equal(n,!0)}),test("drained while idle should resolve",async function(e){const n=buildQueue(async function(e){await sleep(e)},2);await n.drained()}),test("drained while idle should not call the drain function",async function(e){let n=!1;const t=buildQueue(async function(e){await sleep(e)},2);t.drain=function(){n=!0},await t.drained(),e.equal(n,!1)}),test("set this",async function(e){e.plan(1);const n={},t=buildQueue(n,async function(t){e.equal(this,n,"this matches")},1);await t.push(42)}),test("unshift",async function(e){const n=buildQueue(async function(n){e.equal(t.shift(),n,"tasks come in order")},1),t=[1,2,3,4];await Promise.all([n.push(1),n.push(4),n.unshift(3),n.unshift(2)]),e.is(t.length,0)}),test("push with worker throwing error",async function(e){e.plan(5);const n=buildQueue(async function(e,n){throw new Error("test error")},1);n.error(function(n,t){e.ok(n instanceof Error,"global error handler should catch the error"),e.match(n.message,/test error/,'error message should be "test error"'),e.equal(t,42,"The task executed should be passed")});try{await n.push(42)}catch(n){e.ok(n instanceof Error,"push callback should catch the error"),e.match(n.message,/test error/,'error message should be "test error"')}}),test("unshift with worker throwing error",async function(e){e.plan(2);const n=buildQueue(async function(e,n){throw new Error("test error")},1);try{await n.unshift(42)}catch(n){e.ok(n instanceof Error,"push callback should catch the error"),e.match(n.message,/test error/,'error message should be "test error"')}}),test("no unhandledRejection (push)",async function(e){function n(){e.fail("unhandledRejection")}process.once("unhandledRejection",n);buildQueue(async function(e,n){throw new Error("test error")},1).push(42),await immediate(),process.removeListener("unhandledRejection",n)}),test("no unhandledRejection (unshift)",async function(e){function n(){e.fail("unhandledRejection")}process.once("unhandledRejection",n);buildQueue(async function(e,n){throw new Error("test error")},1).unshift(42),await immediate(),process.removeListener("unhandledRejection",n)}),test("drained should resolve after async tasks complete",async function(e){const n=[];const t=buildQueue(async function(){await new Promise(e=>setTimeout(e,0)),n.push("processed")},1);t.drain=()=>n.push("called drain"),t.drained().then(()=>n.push("drained promise resolved")),await Promise.all([t.push(),t.push(),t.push()]),e.deepEqual(n,["processed","processed","processed","called drain","drained promise resolved"],"events happened in correct order")}),test("drained should handle undefined drain function",async function(e){const n=buildQueue(async function(e){return await sleep(10),e},1);n.drain=void 0,n.push(1),await n.drained(),e.pass("drained resolved successfully with undefined drain")});