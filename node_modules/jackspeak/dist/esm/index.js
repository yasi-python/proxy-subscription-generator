import{inspect}from"node:util";import{parseArgs}from"./parse-args.js";import cliui from"@isaacs/cliui";import{basename}from"node:path";const width=Math.min(process&&process.stdout&&process.stdout.columns||80,80),indent=e=>2*(e-1),toEnvKey=(e,t)=>[e,t.replace(/[^a-zA-Z0-9]+/g," ")].join(" ").trim().toUpperCase().replace(/ /g,"_"),toEnvVal=(e,t="\n")=>{const i="string"==typeof e?e:"boolean"==typeof e?e?"1":"0":"number"==typeof e?String(e):Array.isArray(e)?e.map(e=>toEnvVal(e)).join(t):void 0;if("string"!=typeof i)throw new Error(`could not serialize value to environment: ${JSON.stringify(e)}`);return i},fromEnvVal=(e,t,i,n="\n")=>i?e?e.split(n).map(e=>fromEnvVal(e,t,!1)):[]:"string"===t?e:"boolean"===t?"1"===e:+e.trim();export const isConfigType=e=>"string"==typeof e&&("string"===e||"number"===e||"boolean"===e);const undefOrType=(e,t)=>void 0===e||typeof e===t,undefOrTypeArray=(e,t)=>void 0===e||Array.isArray(e)&&e.every(e=>typeof e===t),isValidOption=(e,t)=>Array.isArray(e)?e.every(e=>isValidOption(e,t)):t.includes(e),valueType=e=>"string"==typeof e?"string":"boolean"==typeof e?"boolean":"number"==typeof e?"number":Array.isArray(e)?joinTypes([...new Set(e.map(e=>valueType(e)))])+"[]":`${e.type}${e.multiple?"[]":""}`,joinTypes=e=>1===e.length&&"string"==typeof e[0]?e[0]:`(${e.join("|")})`,isValidValue=(e,t,i)=>i?!!Array.isArray(e)&&!e.some(e=>!isValidValue(e,t,!1)):!Array.isArray(e)&&typeof e===t;export const isConfigOption=(e,t,i)=>!!e&&"object"==typeof e&&isConfigType(e.type)&&e.type===t&&undefOrType(e.short,"string")&&undefOrType(e.description,"string")&&undefOrType(e.hint,"string")&&undefOrType(e.validate,"function")&&("boolean"===e.type?void 0===e.validOptions:undefOrTypeArray(e.validOptions,e.type))&&(void 0===e.default||isValidValue(e.default,t,i))&&!!e.multiple===i;function num(e={}){const{default:t,validate:i,validOptions:n,...o}=e;if(void 0!==t&&!isValidValue(t,"number",!1))throw new TypeError("invalid default value",{cause:{found:t,wanted:"number"}});if(!undefOrTypeArray(n,"number"))throw new TypeError("invalid validOptions",{cause:{found:n,wanted:"number[]"}});return{...o,default:t,validate:i||void 0,validOptions:n,type:"number",multiple:!1}}function numList(e={}){const{default:t,validate:i,validOptions:n,...o}=e;if(void 0!==t&&!isValidValue(t,"number",!0))throw new TypeError("invalid default value",{cause:{found:t,wanted:"number[]"}});if(!undefOrTypeArray(n,"number"))throw new TypeError("invalid validOptions",{cause:{found:n,wanted:"number[]"}});return{...o,default:t,validate:i||void 0,validOptions:n,type:"number",multiple:!0}}function opt(e={}){const{default:t,validate:i,validOptions:n,...o}=e;if(void 0!==t&&!isValidValue(t,"string",!1))throw new TypeError("invalid default value",{cause:{found:t,wanted:"string"}});if(!undefOrTypeArray(n,"string"))throw new TypeError("invalid validOptions",{cause:{found:n,wanted:"string[]"}});return{...o,default:t,validate:i||void 0,validOptions:n,type:"string",multiple:!1}}function optList(e={}){const{default:t,validate:i,validOptions:n,...o}=e;if(void 0!==t&&!isValidValue(t,"string",!0))throw new TypeError("invalid default value",{cause:{found:t,wanted:"string[]"}});if(!undefOrTypeArray(n,"string"))throw new TypeError("invalid validOptions",{cause:{found:n,wanted:"string[]"}});return{...o,default:t,validate:i||void 0,validOptions:n,type:"string",multiple:!0}}function flag(e={}){const{hint:t,default:i,validate:n,...o}=e;if(delete o.validOptions,void 0!==i&&!isValidValue(i,"boolean",!1))throw new TypeError("invalid default value");const s=n||void 0;if(void 0!==t)throw new TypeError("cannot provide hint for flag");return{...o,default:i,validate:s,type:"boolean",multiple:!1}}function flagList(e={}){const{hint:t,default:i,validate:n,...o}=e;if(delete o.validOptions,void 0!==i&&!isValidValue(i,"boolean",!0))throw new TypeError("invalid default value");const s=n||void 0;if(void 0!==t)throw new TypeError("cannot provide hint for flag list");return{...o,default:i,validate:s,type:"boolean",multiple:!0}}const toParseArgsOptionsConfig=e=>{const t={};for(const i in e){const n=e[i];if(!n)throw new Error("config must be an object: "+i);if(isConfigOption(n,"number",!0))t[i]={type:"string",multiple:!0,default:n.default?.map(e=>String(e))};else if(isConfigOption(n,"number",!1))t[i]={type:"string",multiple:!1,default:void 0===n.default?void 0:String(n.default)};else{const e=n;t[i]={type:e.type,multiple:!!e.multiple,default:e.default}}const o=t[i];"string"==typeof n.short&&(o.short=n.short),"boolean"!==n.type||i.startsWith("no-")||e[`no-${i}`]||(t[`no-${i}`]={type:"boolean",multiple:n.multiple})}return t},isHeading=e=>"heading"===e.type,isDescription=e=>"description"===e.type;export class Jack{#e;#t;#i;#n=[];#o;#s;#a;#r;#l;constructor(e={}){this.#i=e,this.#a=!1!==e.allowPositionals,this.#o=void 0===this.#i.env?process.env:this.#i.env,this.#s=e.envPrefix,this.#e=Object.create(null),this.#t=Object.create(null)}setConfigValues(e,t=""){try{this.validate(e)}catch(e){const i=e;throw t&&i&&"object"==typeof i&&(i.cause&&"object"==typeof i.cause?Object.assign(i.cause,{path:t}):i.cause={path:t}),i}for(const[t,i]of Object.entries(e)){const e=this.#e[t];if(!e)throw new Error("unexpected field in config set: "+t,{cause:{found:t}});e.default=i}return this}parse(e=process.argv){this.loadEnvDefaults();const t=this.parseRaw(e);return this.applyDefaults(t),this.writeEnv(t),t}loadEnvDefaults(){if(this.#s)for(const[e,t]of Object.entries(this.#e)){const i=toEnvKey(this.#s,e),n=this.#o[i];void 0!==n&&(t.default=fromEnvVal(n,t.type,!!t.multiple,t.delim))}}applyDefaults(e){for(const[t,i]of Object.entries(this.#e))void 0===i.default||t in e.values||(e.values[t]=i.default)}parseRaw(e){e===process.argv&&(e=e.slice(void 0!==process._eval?1:2));const t=toParseArgsOptionsConfig(this.#e),i=parseArgs({args:e,options:t,strict:!1,allowPositionals:this.#a,tokens:!0}),n={values:{},positionals:[]};for(const t of i.tokens)if("positional"===t.kind){if(n.positionals.push(t.value),this.#i.stopAtPositional||this.#i.stopAtPositionalTest?.(t.value)){n.positionals.push(...e.slice(t.index+1));break}}else if("option"===t.kind){let e;if(t.name.startsWith("no-")){const i=this.#e[t.name],n=t.name.substring(3),o=this.#e[n];o&&"boolean"===o.type&&(!i||"boolean"===i.type&&!!i.multiple==!!o.multiple)&&(e=!1,t.name=n)}const i=this.#e[t.name];if(!i)throw new Error(`Unknown option '${t.rawName}'. To specify a positional argument starting with a '-', place it at the end of the command after '--', as in '-- ${t.rawName}'`,{cause:{found:t.rawName+(t.value?`=${t.value}`:"")}});if(void 0===e)if(void 0===t.value){if("boolean"!==i.type)throw new Error(`No value provided for ${t.rawName}, expected ${i.type}`,{cause:{name:t.rawName,wanted:valueType(i)}});e=!0}else{if("boolean"===i.type)throw new Error(`Flag ${t.rawName} does not take a value, received '${t.value}'`,{cause:{found:t}});if("string"===i.type)e=t.value;else if(e=+t.value,e!=e)throw new Error(`Invalid value '${t.value}' provided for '${t.rawName}' option, expected number`,{cause:{name:t.rawName,found:t.value,wanted:"number"}})}if(i.multiple){const i=n.values,o=i[t.name]??[];i[t.name]=o,o.push(e)}else{n.values[t.name]=e}}for(const[e,t]of Object.entries(n.values)){const i=this.#e[e]?.validate,n=this.#e[e]?.validOptions;let o;if(n&&!isValidOption(t,n)&&(o={name:e,found:t,validOptions:n}),i&&!i(t)&&(o=o||{name:e,found:t}),o)throw new Error(`Invalid value provided for --${e}: ${JSON.stringify(t)}`,{cause:o})}return n}#d(e,t,i=e){if(!e.startsWith("no-")||"boolean"!=typeof t)return;const n=e.substring(3);if(this.#d(n,t,i),"boolean"===this.#e[n]?.type)throw new Error(`do not set '${i}', instead set '${n}' as desired.`,{cause:{found:i,wanted:n}})}validate(e){if(!e||"object"!=typeof e)throw new Error("Invalid config: not an object",{cause:{found:e}});const t=e;for(const i in e){const e=t[i];if(void 0===e)continue;this.#d(i,e);const n=this.#e[i];if(!n)throw new Error(`Unknown config option: ${i}`,{cause:{found:i}});if(!isValidValue(e,n.type,!!n.multiple))throw new Error(`Invalid value ${valueType(e)} for ${i}, expected ${valueType(n)}`,{cause:{name:i,found:e,wanted:valueType(n)}});let o;if(n.validOptions&&!isValidOption(e,n.validOptions)&&(o={name:i,found:e,validOptions:n.validOptions}),n.validate&&!n.validate(e)&&(o=o||{name:i,found:e}),o)throw new Error(`Invalid config value for ${i}: ${e}`,{cause:o})}}writeEnv(e){if(this.#o&&this.#s)for(const[t,i]of Object.entries(e.values)){const e=this.#e[t];this.#o[toEnvKey(this.#s,t)]=toEnvVal(i,e?.delim)}}heading(e,t,{pre:i=!1}={}){return void 0===t&&(t=this.#n.some(e=>isHeading(e))?2:1),this.#n.push({type:"heading",text:e,level:t,pre:i}),this}description(e,{pre:t}={}){return this.#n.push({type:"description",text:e,pre:t}),this}num(e){return this.#p(e,num)}numList(e){return this.#p(e,numList)}opt(e){return this.#p(e,opt)}optList(e){return this.#p(e,optList)}flag(e){return this.#p(e,flag)}flagList(e){return this.#p(e,flagList)}addFields(e){const t=this;for(const[i,n]of Object.entries(e))this.#u(i,n),t.#n.push({type:"config",name:i,value:n});return Object.assign(t.#e,e),t}#p(e,t){const i=this;return Object.assign(i.#e,Object.fromEntries(Object.entries(e).map(([e,n])=>{this.#u(e,n);const o=t(n);return i.#n.push({type:"config",name:e,value:o}),[e,o]}))),i}#u(e,t){if(!/^[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?$/.test(e))throw new TypeError(`Invalid option name: ${e}, must be '-' delimited ASCII alphanumeric`);if(this.#e[e])throw new TypeError(`Cannot redefine option ${t}`);if(this.#t[e])throw new TypeError(`Cannot redefine option ${e}, already in use for ${this.#t[e]}`);if(t.short){if(!/^[a-zA-Z0-9]$/.test(t.short))throw new TypeError(`Invalid ${e} short option: ${t.short}, must be 1 ASCII alphanumeric character`);if(this.#t[t.short])throw new TypeError(`Invalid ${e} short option: ${t.short}, already in use for ${this.#t[t.short]}`);this.#t[t.short]=e,this.#t[e]=e}}usage(){if(this.#r)return this.#r;let e=1;const t=cliui({width:width}),i=this.#n[0];let n="heading"===i?.type?1:0;if("heading"===i?.type&&t.div({padding:[0,0,0,0],text:normalize(i.text)}),t.div({padding:[0,0,0,0],text:"Usage:"}),this.#i.usage)t.div({text:this.#i.usage,padding:[0,0,0,2]});else{const e=basename(String(process.argv[1])),i=[],n=[],o=[],s=[];for(const[e,t]of Object.entries(this.#e))t.short?"boolean"===t.type?i.push(t.short):n.push([t.short,t.hint||e]):"boolean"===t.type?o.push(e):s.push([e,t.hint||e]);const a=`${e}${i.length?" -"+i.join(""):""}${n.map(([e,t])=>` --${e}=<${t}>`).join("")}${o.map(e=>` --${e}`).join("")}${s.map(([e,t])=>` --${e}=<${t}>`).join("")}`.trim();t.div({text:a,padding:[0,0,0,2]})}t.div({padding:[0,0,0,0],text:""});const o=this.#n[n];if(o&&isDescription(o)){const e=normalize(o.text,o.pre);n++,t.div({padding:[0,0,0,0],text:e}),t.div({padding:[0,0,0,0],text:""})}const{rows:s,maxWidth:a}=this.#f(n);for(const i of s)if(i.left){const n=indent(Math.max(e,2));i.left.length>a-3?(t.div({text:i.left,padding:[0,0,0,n]}),t.div({text:i.text,padding:[0,0,0,a]})):t.div({text:i.left,padding:[0,1,0,n],width:a},{padding:[0,0,0,0],text:i.text}),i.skipLine&&t.div({padding:[0,0,0,0],text:""})}else if(isHeading(i)){const{level:n}=i;e=n;const o=n<=2?1:0;t.div({...i,padding:[0,0,o,indent(n)]})}else t.div({...i,padding:[0,0,1,indent(e+1)]});return this.#r=t.toString()}usageMarkdown(){if(this.#l)return this.#l;const e=[];let t=1;const i=this.#n[0];let n="heading"===i?.type?1:0;if("heading"===i?.type&&e.push(`# ${normalizeOneLine(i.text)}`),e.push("Usage:"),this.#i.usage)e.push(normalizeMarkdown(this.#i.usage,!0));else{const t=basename(String(process.argv[1])),i=[],n=[],o=[],s=[];for(const[e,t]of Object.entries(this.#e))t.short?"boolean"===t.type?i.push(t.short):n.push([t.short,t.hint||e]):"boolean"===t.type?o.push(e):s.push([e,t.hint||e]);const a=`${t}${i.length?" -"+i.join(""):""}${n.map(([e,t])=>` --${e}=<${t}>`).join("")}${o.map(e=>` --${e}`).join("")}${s.map(([e,t])=>` --${e}=<${t}>`).join("")}`.trim();e.push(normalizeMarkdown(a,!0))}const o=this.#n[n];o&&isDescription(o)&&(e.push(normalizeMarkdown(o.text,o.pre)),n++);const{rows:s}=this.#f(n);for(const i of s)if(i.left)e.push("#".repeat(t+1)+" "+normalizeOneLine(i.left,!0)),i.text&&e.push(normalizeMarkdown(i.text));else if(isHeading(i)){const{level:n}=i;t=n,e.push(`${"#".repeat(t)} ${normalizeOneLine(i.text,i.pre)}`)}else e.push(normalizeMarkdown(i.text,!!i.pre));return this.#l=e.join("\n\n")+"\n"}#f(e){let t,i=Math.max(12,Math.min(26,Math.floor(width/3))),n=8;const o=[];for(const s of this.#n.slice(e)){if("config"!==s.type){"config"===t?.type&&(t.skipLine=!0),t=void 0,s.text=normalize(s.text,!!s.pre),o.push(s);continue}const{value:e}=s,a=e.description||"",r=e.multiple?"Can be set multiple times":"",l=e.validOptions?.length?`Valid options:${e.validOptions.map(e=>` ${JSON.stringify(e)}`)}`:"",d=a.includes("\n")?"\n\n":"\n",p=[l,r].join(d).trim(),u=(normalize(a)+d+p).trim(),f=e.hint||("number"===e.type?"n":"string"===e.type?s.name:void 0),c=e.short?"boolean"===e.type?`-${e.short} `:`-${e.short}<${f}> `:"",h="boolean"===e.type?`${c}--${s.name}`:`${c}--${s.name}=<${f}>`,v={text:u,left:h,type:"config"};u.length>width-i&&(v.skipLine=!0),t&&h.length>i&&(t.skipLine=!0),t=v;const m=h.length+4;m>n&&m<i&&(n=m),o.push(v)}return{rows:o,maxWidth:n}}toJSON(){return Object.fromEntries(Object.entries(this.#e).map(([e,t])=>[e,{type:t.type,...t.multiple?{multiple:!0}:{},...t.delim?{delim:t.delim}:{},...t.short?{short:t.short}:{},...t.description?{description:normalize(t.description)}:{},...t.validate?{validate:t.validate}:{},...t.validOptions?{validOptions:t.validOptions}:{},...void 0!==t.default?{default:t.default}:{},...t.hint?{hint:t.hint}:{}}]))}[inspect.custom](e,t){return`Jack ${inspect(this.toJSON(),t)}`}}const normalize=(e,t=!1)=>t?e.split("\n").map(e=>`​${e}`).join("\n"):e.split(/^\s*```\s*$/gm).map((e,t)=>{if(t%2==1){if(!e.trim())return"```\n```\n";const t=e.split("\n");t.pop(),t.shift();const i=t.reduce((e,t)=>{const i=t.match(/^\s*/)?.[0]??"";return i.length?Math.min(i.length,e):e},1/0),n=isFinite(i)?i:0;return"\n```\n"+t.map(e=>`​${e.substring(n)}`).join("\n")+"\n```\n"}return e.replace(/([^\n])\n[ \t]*([^\n])/g,(e,t,i)=>/^[-*]/.test(i)?`${t}\n${i}`:`${t} ${i}`).replace(/([^\n])[ \t]+([^\n])/g,"$1 $2").replace(/\n{3,}/g,"\n\n").replace(/\n[ \t]+/g,"\n").trim()}).join("\n"),normalizeMarkdown=(e,t=!1)=>{const i=normalize(e,t).replace(/\\/g,"\\\\");return t?`\`\`\`\n${i.replace(/\u200b/g,"")}\n\`\`\``:i.replace(/\n +/g,"\n").trim()},normalizeOneLine=(e,t=!1)=>{const i=normalize(e,t).replace(/[\s\u200b]+/g," ").trim();return t?`\`${i}\``:i};export const jack=(e={})=>new Jack(e);