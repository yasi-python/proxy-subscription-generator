import{inspect}from"node:util";import{parseArgs}from"./parse-args.js";import cliui from"@isaacs/cliui";import{basename}from"node:path";const width=Math.min(process&&process.stdout&&process.stdout.columns||80,80),indent=t=>2*(t-1),toEnvKey=(t,e)=>[t,e.replace(/[^a-zA-Z0-9]+/g," ")].join(" ").trim().toUpperCase().replace(/ /g,"_"),toEnvVal=(t,e="\n")=>{const i="string"==typeof t?t:"boolean"==typeof t?t?"1":"0":"number"==typeof t?String(t):Array.isArray(t)?t.map(t=>toEnvVal(t)).join(e):void 0;if("string"!=typeof i)throw new Error(`could not serialize value to environment: ${JSON.stringify(t)}`);return i},fromEnvVal=(t,e,i,n="\n")=>i?t?t.split(n).map(t=>fromEnvVal(t,e,!1)):[]:"string"===e?t:"boolean"===e?"1"===t:+t.trim();export const isConfigType=t=>"string"==typeof t&&("string"===t||"number"===t||"boolean"===t);const undefOrType=(t,e)=>void 0===t||typeof t===e,undefOrTypeArray=(t,e)=>void 0===t||Array.isArray(t)&&t.every(t=>typeof t===e),isValidOption=(t,e)=>Array.isArray(t)?t.every(t=>isValidOption(t,e)):e.includes(t),valueType=t=>"string"==typeof t?"string":"boolean"==typeof t?"boolean":"number"==typeof t?"number":Array.isArray(t)?joinTypes([...new Set(t.map(t=>valueType(t)))])+"[]":`${t.type}${t.multiple?"[]":""}`,joinTypes=t=>1===t.length&&"string"==typeof t[0]?t[0]:`(${t.join("|")})`,isValidValue=(t,e,i)=>i?!!Array.isArray(t)&&!t.some(t=>!isValidValue(t,e,!1)):!Array.isArray(t)&&typeof t===e;export const isConfigOption=(t,e,i)=>!!t&&"object"==typeof t&&isConfigType(t.type)&&t.type===e&&undefOrType(t.short,"string")&&undefOrType(t.description,"string")&&undefOrType(t.hint,"string")&&undefOrType(t.validate,"function")&&("boolean"===t.type?void 0===t.validOptions:undefOrTypeArray(t.validOptions,t.type))&&(void 0===t.default||isValidValue(t.default,e,i))&&!!t.multiple===i;function num(t={}){const{default:e,validate:i,validOptions:n,...o}=t;if(void 0!==e&&!isValidValue(e,"number",!1))throw new TypeError("invalid default value",{cause:{found:e,wanted:"number"}});if(!undefOrTypeArray(n,"number"))throw new TypeError("invalid validOptions",{cause:{found:n,wanted:"number[]"}});return{...o,default:e,validate:i||void 0,validOptions:n,type:"number",multiple:!1}}function numList(t={}){const{default:e,validate:i,validOptions:n,...o}=t;if(void 0!==e&&!isValidValue(e,"number",!0))throw new TypeError("invalid default value",{cause:{found:e,wanted:"number[]"}});if(!undefOrTypeArray(n,"number"))throw new TypeError("invalid validOptions",{cause:{found:n,wanted:"number[]"}});return{...o,default:e,validate:i||void 0,validOptions:n,type:"number",multiple:!0}}function opt(t={}){const{default:e,validate:i,validOptions:n,...o}=t;if(void 0!==e&&!isValidValue(e,"string",!1))throw new TypeError("invalid default value",{cause:{found:e,wanted:"string"}});if(!undefOrTypeArray(n,"string"))throw new TypeError("invalid validOptions",{cause:{found:n,wanted:"string[]"}});return{...o,default:e,validate:i||void 0,validOptions:n,type:"string",multiple:!1}}function optList(t={}){const{default:e,validate:i,validOptions:n,...o}=t;if(void 0!==e&&!isValidValue(e,"string",!0))throw new TypeError("invalid default value",{cause:{found:e,wanted:"string[]"}});if(!undefOrTypeArray(n,"string"))throw new TypeError("invalid validOptions",{cause:{found:n,wanted:"string[]"}});return{...o,default:e,validate:i||void 0,validOptions:n,type:"string",multiple:!0}}function flag(t={}){const{hint:e,default:i,validate:n,...o}=t;if(delete o.validOptions,void 0!==i&&!isValidValue(i,"boolean",!1))throw new TypeError("invalid default value");const s=n||void 0;if(void 0!==e)throw new TypeError("cannot provide hint for flag");return{...o,default:i,validate:s,type:"boolean",multiple:!1}}function flagList(t={}){const{hint:e,default:i,validate:n,...o}=t;if(delete o.validOptions,void 0!==i&&!isValidValue(i,"boolean",!0))throw new TypeError("invalid default value");const s=n||void 0;if(void 0!==e)throw new TypeError("cannot provide hint for flag list");return{...o,default:i,validate:s,type:"boolean",multiple:!0}}const toParseArgsOptionsConfig=t=>{const e={};for(const i in t){const n=t[i];if(!n)throw new Error("config must be an object: "+i);if(isConfigOption(n,"number",!0))e[i]={type:"string",multiple:!0,default:n.default?.map(t=>String(t))};else if(isConfigOption(n,"number",!1))e[i]={type:"string",multiple:!1,default:void 0===n.default?void 0:String(n.default)};else{const t=n;e[i]={type:t.type,multiple:!!t.multiple,default:t.default}}const o=e[i];"string"==typeof n.short&&(o.short=n.short),"boolean"!==n.type||i.startsWith("no-")||t[`no-${i}`]||(e[`no-${i}`]={type:"boolean",multiple:n.multiple})}return e},isHeading=t=>"heading"===t.type,isDescription=t=>"description"===t.type;export class Jack{#t;#e;#i;#n=[];#o;#s;#r;#a;#l;constructor(t={}){this.#i=t,this.#r=!1!==t.allowPositionals,this.#o=void 0===this.#i.env?process.env:this.#i.env,this.#s=t.envPrefix,this.#t=Object.create(null),this.#e=Object.create(null)}setConfigValues(t,e=""){try{this.validate(t)}catch(t){const i=t;throw e&&i&&"object"==typeof i&&(i.cause&&"object"==typeof i.cause?Object.assign(i.cause,{path:e}):i.cause={path:e}),i}for(const[e,i]of Object.entries(t)){const t=this.#t[e];if(!t)throw new Error("unexpected field in config set: "+e,{cause:{found:e}});t.default=i}return this}parse(t=process.argv){this.loadEnvDefaults();const e=this.parseRaw(t);return this.applyDefaults(e),this.writeEnv(e),e}loadEnvDefaults(){if(this.#s)for(const[t,e]of Object.entries(this.#t)){const i=toEnvKey(this.#s,t),n=this.#o[i];void 0!==n&&(e.default=fromEnvVal(n,e.type,!!e.multiple,e.delim))}}applyDefaults(t){for(const[e,i]of Object.entries(this.#t))void 0===i.default||e in t.values||(t.values[e]=i.default)}parseRaw(t){t===process.argv&&(t=t.slice(void 0!==process._eval?1:2));const e=toParseArgsOptionsConfig(this.#t),i=parseArgs({args:t,options:e,strict:!1,allowPositionals:this.#r,tokens:!0}),n={values:{},positionals:[]};for(const e of i.tokens)if("positional"===e.kind){if(n.positionals.push(e.value),this.#i.stopAtPositional||this.#i.stopAtPositionalTest?.(e.value)){n.positionals.push(...t.slice(e.index+1));break}}else if("option"===e.kind){let t;if(e.name.startsWith("no-")){const i=this.#t[e.name],n=e.name.substring(3),o=this.#t[n];o&&"boolean"===o.type&&(!i||"boolean"===i.type&&!!i.multiple==!!o.multiple)&&(t=!1,e.name=n)}const i=this.#t[e.name];if(!i)throw new Error(`Unknown option '${e.rawName}'. To specify a positional argument starting with a '-', place it at the end of the command after '--', as in '-- ${e.rawName}'`,{cause:{found:e.rawName+(e.value?`=${e.value}`:"")}});if(void 0===t)if(void 0===e.value){if("boolean"!==i.type)throw new Error(`No value provided for ${e.rawName}, expected ${i.type}`,{cause:{name:e.rawName,wanted:valueType(i)}});t=!0}else{if("boolean"===i.type)throw new Error(`Flag ${e.rawName} does not take a value, received '${e.value}'`,{cause:{found:e}});if("string"===i.type)t=e.value;else if(t=+e.value,t!=t)throw new Error(`Invalid value '${e.value}' provided for '${e.rawName}' option, expected number`,{cause:{name:e.rawName,found:e.value,wanted:"number"}})}if(i.multiple){const i=n.values,o=i[e.name]??[];i[e.name]=o,o.push(t)}else n.values[e.name]=t}for(const[t,e]of Object.entries(n.values)){const i=this.#t[t]?.validate,n=this.#t[t]?.validOptions;let o;if(n&&!isValidOption(e,n)&&(o={name:t,found:e,validOptions:n}),i&&!i(e)&&(o=o||{name:t,found:e}),o)throw new Error(`Invalid value provided for --${t}: ${JSON.stringify(e)}`,{cause:o})}return n}#p(t,e,i=t){if(!t.startsWith("no-")||"boolean"!=typeof e)return;const n=t.substring(3);if(this.#p(n,e,i),"boolean"===this.#t[n]?.type)throw new Error(`do not set '${i}', instead set '${n}' as desired.`,{cause:{found:i,wanted:n}})}validate(t){if(!t||"object"!=typeof t)throw new Error("Invalid config: not an object",{cause:{found:t}});const e=t;for(const i in t){const t=e[i];if(void 0===t)continue;this.#p(i,t);const n=this.#t[i];if(!n)throw new Error(`Unknown config option: ${i}`,{cause:{found:i}});if(!isValidValue(t,n.type,!!n.multiple))throw new Error(`Invalid value ${valueType(t)} for ${i}, expected ${valueType(n)}`,{cause:{name:i,found:t,wanted:valueType(n)}});let o;if(n.validOptions&&!isValidOption(t,n.validOptions)&&(o={name:i,found:t,validOptions:n.validOptions}),n.validate&&!n.validate(t)&&(o=o||{name:i,found:t}),o)throw new Error(`Invalid config value for ${i}: ${t}`,{cause:o})}}writeEnv(t){if(this.#o&&this.#s)for(const[e,i]of Object.entries(t.values)){const t=this.#t[e];this.#o[toEnvKey(this.#s,e)]=toEnvVal(i,t?.delim)}}heading(t,e,{pre:i=!1}={}){return void 0===e&&(e=this.#n.some(t=>isHeading(t))?2:1),this.#n.push({type:"heading",text:t,level:e,pre:i}),this}description(t,{pre:e}={}){return this.#n.push({type:"description",text:t,pre:e}),this}num(t){return this.#d(t,num)}numList(t){return this.#d(t,numList)}opt(t){return this.#d(t,opt)}optList(t){return this.#d(t,optList)}flag(t){return this.#d(t,flag)}flagList(t){return this.#d(t,flagList)}addFields(t){const e=this;for(const[i,n]of Object.entries(t))this.#u(i,n),e.#n.push({type:"config",name:i,value:n});return Object.assign(e.#t,t),e}#d(t,e){const i=this;return Object.assign(i.#t,Object.fromEntries(Object.entries(t).map(([t,n])=>{this.#u(t,n);const o=e(n);return i.#n.push({type:"config",name:t,value:o}),[t,o]}))),i}#u(t,e){if(!/^[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?$/.test(t))throw new TypeError(`Invalid option name: ${t}, must be '-' delimited ASCII alphanumeric`);if(this.#t[t])throw new TypeError(`Cannot redefine option ${e}`);if(this.#e[t])throw new TypeError(`Cannot redefine option ${t}, already in use for ${this.#e[t]}`);if(e.short){if(!/^[a-zA-Z0-9]$/.test(e.short))throw new TypeError(`Invalid ${t} short option: ${e.short}, must be 1 ASCII alphanumeric character`);if(this.#e[e.short])throw new TypeError(`Invalid ${t} short option: ${e.short}, already in use for ${this.#e[e.short]}`);this.#e[e.short]=t,this.#e[t]=t}}usage(){if(this.#a)return this.#a;let t=1;const e=cliui({width:width}),i=this.#n[0];let n="heading"===i?.type?1:0;if("heading"===i?.type&&e.div({padding:[0,0,0,0],text:normalize(i.text)}),e.div({padding:[0,0,0,0],text:"Usage:"}),this.#i.usage)e.div({text:this.#i.usage,padding:[0,0,0,2]});else{const t=basename(String(process.argv[1])),i=[],n=[],o=[],s=[];for(const[t,e]of Object.entries(this.#t))e.short?"boolean"===e.type?i.push(e.short):n.push([e.short,e.hint||t]):"boolean"===e.type?o.push(t):s.push([t,e.hint||t]);const r=`${t}${i.length?" -"+i.join(""):""}${n.map(([t,e])=>` --${t}=<${e}>`).join("")}${o.map(t=>` --${t}`).join("")}${s.map(([t,e])=>` --${t}=<${e}>`).join("")}`.trim();e.div({text:r,padding:[0,0,0,2]})}e.div({padding:[0,0,0,0],text:""});const o=this.#n[n];if(o&&isDescription(o)){const t=normalize(o.text,o.pre);n++,e.div({padding:[0,0,0,0],text:t}),e.div({padding:[0,0,0,0],text:""})}const{rows:s,maxWidth:r}=this.#f(n);for(const i of s)if(i.left){const n=indent(Math.max(t,2));i.left.length>r-3?(e.div({text:i.left,padding:[0,0,0,n]}),e.div({text:i.text,padding:[0,0,0,r]})):e.div({text:i.left,padding:[0,1,0,n],width:r},{padding:[0,0,0,0],text:i.text}),i.skipLine&&e.div({padding:[0,0,0,0],text:""})}else if(isHeading(i)){const{level:n}=i;t=n;const o=n<=2?1:0;e.div({...i,padding:[0,0,o,indent(n)]})}else e.div({...i,padding:[0,0,1,indent(t+1)]});return this.#a=e.toString()}usageMarkdown(){if(this.#l)return this.#l;const t=[];let e=1;const i=this.#n[0];let n="heading"===i?.type?1:0;if("heading"===i?.type&&t.push(`# ${normalizeOneLine(i.text)}`),t.push("Usage:"),this.#i.usage)t.push(normalizeMarkdown(this.#i.usage,!0));else{const e=basename(String(process.argv[1])),i=[],n=[],o=[],s=[];for(const[t,e]of Object.entries(this.#t))e.short?"boolean"===e.type?i.push(e.short):n.push([e.short,e.hint||t]):"boolean"===e.type?o.push(t):s.push([t,e.hint||t]);const r=`${e}${i.length?" -"+i.join(""):""}${n.map(([t,e])=>` --${t}=<${e}>`).join("")}${o.map(t=>` --${t}`).join("")}${s.map(([t,e])=>` --${t}=<${e}>`).join("")}`.trim();t.push(normalizeMarkdown(r,!0))}const o=this.#n[n];o&&isDescription(o)&&(t.push(normalizeMarkdown(o.text,o.pre)),n++);const{rows:s}=this.#f(n);for(const i of s)if(i.left)t.push("#".repeat(e+1)+" "+normalizeOneLine(i.left,!0)),i.text&&t.push(normalizeMarkdown(i.text));else if(isHeading(i)){const{level:n}=i;e=n,t.push(`${"#".repeat(e)} ${normalizeOneLine(i.text,i.pre)}`)}else t.push(normalizeMarkdown(i.text,!!i.pre));return this.#l=t.join("\n\n")+"\n"}#f(t){let e,i=Math.max(12,Math.min(26,Math.floor(width/3))),n=8;const o=[];for(const s of this.#n.slice(t)){if("config"!==s.type){"config"===e?.type&&(e.skipLine=!0),e=void 0,s.text=normalize(s.text,!!s.pre),o.push(s);continue}const{value:t}=s,r=t.description||"",a=t.multiple?"Can be set multiple times":"",l=t.validOptions?.length?`Valid options:${t.validOptions.map(t=>` ${JSON.stringify(t)}`)}`:"",p=r.includes("\n")?"\n\n":"\n",d=[l,a].join(p).trim(),u=(normalize(r)+p+d).trim(),f=t.hint||("number"===t.type?"n":"string"===t.type?s.name:void 0),h=t.short?"boolean"===t.type?`-${t.short} `:`-${t.short}<${f}> `:"",c="boolean"===t.type?`${h}--${s.name}`:`${h}--${s.name}=<${f}>`,v={text:u,left:c,type:"config"};u.length>width-i&&(v.skipLine=!0),e&&c.length>i&&(e.skipLine=!0),e=v;const m=c.length+4;m>n&&m<i&&(n=m),o.push(v)}return{rows:o,maxWidth:n}}toJSON(){return Object.fromEntries(Object.entries(this.#t).map(([t,e])=>[t,{type:e.type,...e.multiple?{multiple:!0}:{},...e.delim?{delim:e.delim}:{},...e.short?{short:e.short}:{},...e.description?{description:normalize(e.description)}:{},...e.validate?{validate:e.validate}:{},...e.validOptions?{validOptions:e.validOptions}:{},...void 0!==e.default?{default:e.default}:{},...e.hint?{hint:e.hint}:{}}]))}[inspect.custom](t,e){return`Jack ${inspect(this.toJSON(),e)}`}}const normalize=(t,e=!1)=>e?t.split("\n").map(t=>`​${t}`).join("\n"):t.split(/^\s*```\s*$/gm).map((t,e)=>{if(e%2==1){if(!t.trim())return"```\n```\n";const e=t.split("\n");e.pop(),e.shift();const i=e.reduce((t,e)=>{const i=e.match(/^\s*/)?.[0]??"";return i.length?Math.min(i.length,t):t},1/0),n=isFinite(i)?i:0;return"\n```\n"+e.map(t=>`​${t.substring(n)}`).join("\n")+"\n```\n"}return t.replace(/([^\n])\n[ \t]*([^\n])/g,(t,e,i)=>/^[-*]/.test(i)?`${e}\n${i}`:`${e} ${i}`).replace(/([^\n])[ \t]+([^\n])/g,"$1 $2").replace(/\n{3,}/g,"\n\n").replace(/\n[ \t]+/g,"\n").trim()}).join("\n"),normalizeMarkdown=(t,e=!1)=>{const i=normalize(t,e).replace(/\\/g,"\\\\");return e?`\`\`\`\n${i.replace(/\u200b/g,"")}\n\`\`\``:i.replace(/\n +/g,"\n").trim()},normalizeOneLine=(t,e=!1)=>{const i=normalize(t,e).replace(/[\s\u200b]+/g," ").trim();return e?`\`${i}\``:i};export const jack=(t={})=>new Jack(t);