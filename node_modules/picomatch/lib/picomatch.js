"use strict";const path=require("path"),scan=require("./scan"),parse=require("./parse"),utils=require("./utils"),constants=require("./constants"),isObject=t=>t&&"object"==typeof t&&!Array.isArray(t),picomatch=(t,e,o=!1)=>{if(Array.isArray(t)){const a=t.map(t=>picomatch(t,e,o)),c=t=>{for(const e of a){const o=e(t);if(o)return o}return!1};return c}const a=isObject(t)&&t.tokens&&t.input;if(""===t||"string"!=typeof t&&!a)throw new TypeError("Expected pattern to be a non-empty string");const c=e||{},s=utils.isWindows(e),n=a?picomatch.compileRe(t,e):picomatch.makeRe(t,e,!1,!0),r=n.state;delete n.state;let i=()=>!1;if(c.ignore){const t={...e,ignore:null,onMatch:null,onResult:null};i=picomatch(c.ignore,t,o)}const p=(o,a=!1)=>{const{isMatch:p,match:u,output:h}=picomatch.test(o,n,e,{glob:t,posix:s}),m={glob:t,state:r,regex:n,posix:s,input:o,output:h,match:u,isMatch:p};return"function"==typeof c.onResult&&c.onResult(m),!1===p?(m.isMatch=!1,!!a&&m):i(o)?("function"==typeof c.onIgnore&&c.onIgnore(m),m.isMatch=!1,!!a&&m):("function"==typeof c.onMatch&&c.onMatch(m),!a||m)};return o&&(p.state=r),p};picomatch.test=(t,e,o,{glob:a,posix:c}={})=>{if("string"!=typeof t)throw new TypeError("Expected input to be a string");if(""===t)return{isMatch:!1,output:""};const s=o||{},n=s.format||(c?utils.toPosixSlashes:null);let r=t===a,i=r&&n?n(t):t;return!1===r&&(i=n?n(t):t,r=i===a),!1!==r&&!0!==s.capture||(r=!0===s.matchBase||!0===s.basename?picomatch.matchBase(t,e,o,c):e.exec(i)),{isMatch:Boolean(r),match:r,output:i}},picomatch.matchBase=(t,e,o,a=utils.isWindows(o))=>(e instanceof RegExp?e:picomatch.makeRe(e,o)).test(path.basename(t)),picomatch.isMatch=(t,e,o)=>picomatch(e,o)(t),picomatch.parse=(t,e)=>Array.isArray(t)?t.map(t=>picomatch.parse(t,e)):parse(t,{...e,fastpaths:!1}),picomatch.scan=(t,e)=>scan(t,e),picomatch.compileRe=(t,e,o=!1,a=!1)=>{if(!0===o)return t.output;const c=e||{},s=c.contains?"":"^",n=c.contains?"":"$";let r=`${s}(?:${t.output})${n}`;t&&!0===t.negated&&(r=`^(?!${r}).*$`);const i=picomatch.toRegex(r,e);return!0===a&&(i.state=t),i},picomatch.makeRe=(t,e={},o=!1,a=!1)=>{if(!t||"string"!=typeof t)throw new TypeError("Expected a non-empty string");let c={negated:!1,fastpaths:!0};return!1===e.fastpaths||"."!==t[0]&&"*"!==t[0]||(c.output=parse.fastpaths(t,e)),c.output||(c=parse(t,e)),picomatch.compileRe(c,e,o,a)},picomatch.toRegex=(t,e)=>{try{const o=e||{};return new RegExp(t,o.flags||(o.nocase?"i":""))}catch(t){if(e&&!0===e.debug)throw t;return/$^/}},picomatch.constants=constants,module.exports=picomatch;