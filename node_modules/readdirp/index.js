"use strict";const fs=require("fs"),{Readable:Readable}=require("stream"),sysPath=require("path"),{promisify:promisify}=require("util"),picomatch=require("picomatch"),readdir=promisify(fs.readdir),stat=promisify(fs.stat),lstat=promisify(fs.lstat),realpath=promisify(fs.realpath),BANG="!",RECURSIVE_ERROR_CODE="READDIRP_RECURSIVE_ERROR",NORMAL_FLOW_ERRORS=new Set(["ENOENT","EPERM","EACCES","ELOOP",RECURSIVE_ERROR_CODE]),FILE_TYPE="files",DIR_TYPE="directories",FILE_DIR_TYPE="files_directories",EVERYTHING_TYPE="all",ALL_TYPES=[FILE_TYPE,DIR_TYPE,FILE_DIR_TYPE,EVERYTHING_TYPE],isNormalFlowError=t=>NORMAL_FLOW_ERRORS.has(t.code),[maj,min]=process.versions.node.split(".").slice(0,2).map(t=>Number.parseInt(t,10)),wantBigintFsStats="win32"===process.platform&&(maj>10||10===maj&&min>=5),normalizeFilter=t=>{if(void 0!==t){if("function"==typeof t)return t;if("string"==typeof t){const r=picomatch(t.trim());return t=>r(t.basename)}if(Array.isArray(t)){const r=[],i=[];for(const e of t){const t=e.trim();"!"===t.charAt(0)?i.push(picomatch(t.slice(1))):r.push(picomatch(t))}return i.length>0?r.length>0?t=>r.some(r=>r(t.basename))&&!i.some(r=>r(t.basename)):t=>!i.some(r=>r(t.basename)):t=>r.some(r=>r(t.basename))}}};class ReaddirpStream extends Readable{static get defaultOptions(){return{root:".",fileFilter:t=>!0,directoryFilter:t=>!0,type:FILE_TYPE,lstat:!1,depth:2147483648,alwaysStat:!1}}constructor(t={}){super({objectMode:!0,autoDestroy:!0,highWaterMark:t.highWaterMark||4096});const r={...ReaddirpStream.defaultOptions,...t},{root:i,type:e}=r;this._fileFilter=normalizeFilter(r.fileFilter),this._directoryFilter=normalizeFilter(r.directoryFilter);const s=r.lstat?lstat:stat;this._stat=wantBigintFsStats?t=>s(t,{bigint:!0}):s,this._maxDepth=r.depth,this._wantsDir=[DIR_TYPE,FILE_DIR_TYPE,EVERYTHING_TYPE].includes(e),this._wantsFile=[FILE_TYPE,FILE_DIR_TYPE,EVERYTHING_TYPE].includes(e),this._wantsEverything=e===EVERYTHING_TYPE,this._root=sysPath.resolve(i),this._isDirent="Dirent"in fs&&!r.alwaysStat,this._statsProp=this._isDirent?"dirent":"stats",this._rdOptions={encoding:"utf8",withFileTypes:this._isDirent},this.parents=[this._exploreDir(i,1)],this.reading=!1,this.parent=void 0}async _read(t){if(!this.reading){this.reading=!0;try{for(;!this.destroyed&&t>0;){const{path:r,depth:i,files:e=[]}=this.parent||{};if(e.length>0){const s=e.splice(0,t).map(t=>this._formatEntry(t,r));for(const r of await Promise.all(s)){if(this.destroyed)return;const e=await this._getEntryType(r);"directory"===e&&this._directoryFilter(r)?(i<=this._maxDepth&&this.parents.push(this._exploreDir(r.fullPath,i+1)),this._wantsDir&&(this.push(r),t--)):("file"===e||this._includeAsFile(r))&&this._fileFilter(r)&&this._wantsFile&&(this.push(r),t--)}}else{const t=this.parents.pop();if(!t){this.push(null);break}if(this.parent=await t,this.destroyed)return}}}catch(t){this.destroy(t)}finally{this.reading=!1}}}async _exploreDir(t,r){let i;try{i=await readdir(t,this._rdOptions)}catch(t){this._onError(t)}return{files:i,depth:r,path:t}}async _formatEntry(t,r){let i;try{const e=this._isDirent?t.name:t,s=sysPath.resolve(sysPath.join(r,e));i={path:sysPath.relative(this._root,s),fullPath:s,basename:e},i[this._statsProp]=this._isDirent?t:await this._stat(s)}catch(t){this._onError(t)}return i}_onError(t){isNormalFlowError(t)&&!this.destroyed?this.emit("warn",t):this.destroy(t)}async _getEntryType(t){const r=t&&t[this._statsProp];if(r){if(r.isFile())return"file";if(r.isDirectory())return"directory";if(r&&r.isSymbolicLink()){const r=t.fullPath;try{const t=await realpath(r),i=await lstat(t);if(i.isFile())return"file";if(i.isDirectory()){const i=t.length;if(r.startsWith(t)&&r.substr(i,1)===sysPath.sep){const i=new Error(`Circular symlink detected: "${r}" points to "${t}"`);return i.code=RECURSIVE_ERROR_CODE,this._onError(i)}return"directory"}}catch(t){this._onError(t)}}}}_includeAsFile(t){const r=t&&t[this._statsProp];return r&&this._wantsEverything&&!r.isDirectory()}}const readdirp=(t,r={})=>{let i=r.entryType||r.type;if("both"===i&&(i=FILE_DIR_TYPE),i&&(r.type=i),!t)throw new Error("readdirp: root argument is required. Usage: readdirp(root, options)");if("string"!=typeof t)throw new TypeError("readdirp: root argument must be a string. Usage: readdirp(root, options)");if(i&&!ALL_TYPES.includes(i))throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(", ")}`);return r.root=t,new ReaddirpStream(r)},readdirpPromise=(t,r={})=>new Promise((i,e)=>{const s=[];readdirp(t,r).on("data",t=>s.push(t)).on("end",()=>i(s)).on("error",t=>e(t))});readdirp.promise=readdirpPromise,readdirp.ReaddirpStream=ReaddirpStream,readdirp.default=readdirp,module.exports=readdirp;