"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const events_1=require("events"),fsScandir=require("@nodelib/fs.scandir"),fastq=require("fastq"),common=require("./common"),reader_1=require("./reader");class AsyncReader extends reader_1.default{constructor(e,t){super(e,t),this._settings=t,this._scandir=fsScandir.scandir,this._emitter=new events_1.EventEmitter,this._queue=fastq(this._worker.bind(this),this._settings.concurrency),this._isFatalError=!1,this._isDestroyed=!1,this._queue.drain=()=>{this._isFatalError||this._emitter.emit("end")}}read(){return this._isFatalError=!1,this._isDestroyed=!1,setImmediate(()=>{this._pushToQueue(this._root,this._settings.basePath)}),this._emitter}get isDestroyed(){return this._isDestroyed}destroy(){if(this._isDestroyed)throw new Error("The reader is already destroyed");this._isDestroyed=!0,this._queue.killAndDrain()}onEntry(e){this._emitter.on("entry",e)}onError(e){this._emitter.once("error",e)}onEnd(e){this._emitter.once("end",e)}_pushToQueue(e,t){const r={directory:e,base:t};this._queue.push(r,e=>{null!==e&&this._handleError(e)})}_worker(e,t){this._scandir(e.directory,this._settings.fsScandirSettings,(r,s)=>{if(null===r){for(const t of s)this._handleEntry(t,e.base);t(null,void 0)}else t(r,void 0)})}_handleError(e){!this._isDestroyed&&common.isFatalError(this._settings,e)&&(this._isFatalError=!0,this._isDestroyed=!0,this._emitter.emit("error",e))}_handleEntry(e,t){if(this._isDestroyed||this._isFatalError)return;const r=e.path;void 0!==t&&(e.path=common.joinPathSegments(t,e.name,this._settings.pathSegmentSeparator)),common.isAppliedFilter(this._settings.entryFilter,e)&&this._emitEntry(e),e.dirent.isDirectory()&&common.isAppliedFilter(this._settings.deepFilter,e)&&this._pushToQueue(r,void 0===t?void 0:e.path)}_emitEntry(e){this._emitter.emit("entry",e)}}exports.default=AsyncReader;