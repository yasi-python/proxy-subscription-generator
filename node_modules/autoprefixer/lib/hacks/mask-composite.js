let Declaration=require("../declaration");class MaskComposite extends Declaration{insert(e,s,o){let t,a="mask-composite"===e.prop;t=a?e.value.split(","):e.value.match(MaskComposite.regexp)||[],t=t.map(e=>e.trim()).filter(e=>e);let r,i=t.length;if(i&&(r=this.clone(e),r.value=t.map(e=>MaskComposite.oldValues[e]||e).join(", "),t.includes("intersect")&&(r.value+=", xor"),r.prop=s+"mask-composite"),a){if(!i)return;return this.needCascade(e)&&(r.raws.before=this.calcBefore(o,e,s)),e.parent.insertBefore(e,r)}let l=this.clone(e);return l.prop=s+l.prop,i&&(l.value=l.value.replace(MaskComposite.regexp,"")),this.needCascade(e)&&(l.raws.before=this.calcBefore(o,e,s)),e.parent.insertBefore(e,l),i?(this.needCascade(e)&&(r.raws.before=this.calcBefore(o,e,s)),e.parent.insertBefore(e,r)):e}}MaskComposite.names=["mask","mask-composite"],MaskComposite.oldValues={add:"source-over",exclude:"xor",intersect:"source-in",subtract:"source-out"},MaskComposite.regexp=new RegExp(`\\s+(${Object.keys(MaskComposite.oldValues).join("|")})\\b(?!\\))\\s*(?=[,])`,"ig"),module.exports=MaskComposite;