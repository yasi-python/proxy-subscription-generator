const flagSymbol=Symbol("arg flag");class ArgError extends Error{constructor(r,e){super(r),this.name="ArgError",this.code=e,Object.setPrototypeOf(this,ArgError.prototype)}}function arg(r,{argv:e=process.argv.slice(2),permissive:t=!1,stopAtPositional:o=!1}={}){if(!r)throw new ArgError("argument specification object is required","ARG_CONFIG_NO_SPEC");const n={_:[]},i={},a={};for(const e of Object.keys(r)){if(!e)throw new ArgError("argument key cannot be an empty string","ARG_CONFIG_EMPTY_KEY");if("-"!==e[0])throw new ArgError(`argument key must start with '-' but found: '${e}'`,"ARG_CONFIG_NONOPT_KEY");if(1===e.length)throw new ArgError(`argument key must have a name; singular '-' keys are not allowed: ${e}`,"ARG_CONFIG_NONAME_KEY");if("string"==typeof r[e]){i[e]=r[e];continue}let t=r[e],o=!1;if(Array.isArray(t)&&1===t.length&&"function"==typeof t[0]){const[r]=t;t=(e,t,o=[])=>(o.push(r(e,t,o[o.length-1])),o),o=r===Boolean||!0===r[flagSymbol]}else{if("function"!=typeof t)throw new ArgError(`type missing or not a function or valid array type: ${e}`,"ARG_CONFIG_VAD_TYPE");o=t===Boolean||!0===t[flagSymbol]}if("-"!==e[1]&&e.length>2)throw new ArgError(`short argument keys (with a single hyphen) must have only one character: ${e}`,"ARG_CONFIG_SHORTOPT_TOOLONG");a[e]=[t,o]}for(let r=0,s=e.length;r<s;r++){const s=e[r];if(o&&n._.length>0){n._=n._.concat(e.slice(r));break}if("--"===s){n._=n._.concat(e.slice(r+1));break}if(s.length>1&&"-"===s[0]){const o="-"===s[1]||2===s.length?[s]:s.slice(1).split("").map(r=>`-${r}`);for(let s=0;s<o.length;s++){const g=o[s],[l,f]="-"===g[1]?g.split(/=(.*)/,2):[g,void 0];let h=l;for(;h in i;)h=i[h];if(!(h in a)){if(t){n._.push(g);continue}throw new ArgError(`unknown or unexpected option: ${l}`,"ARG_UNKNOWN_OPTION")}const[c,u]=a[h];if(!u&&s+1<o.length)throw new ArgError(`option requires argument (but was followed by another short argument): ${l}`,"ARG_MISSING_REQUIRED_SHORTARG");if(u)n[h]=c(!0,h,n[h]);else if(void 0===f){if(e.length<r+2||e[r+1].length>1&&"-"===e[r+1][0]&&(!e[r+1].match(/^-?\d*(\.(?=\d))?\d*$/)||c!==Number&&("undefined"==typeof BigInt||c!==BigInt)))throw new ArgError(`option requires argument: ${l}${l===h?"":` (alias for ${h})`}`,"ARG_MISSING_REQUIRED_LONGARG");n[h]=c(e[r+1],h,n[h]),++r}else n[h]=c(f,h,n[h])}}else n._.push(s)}return n}arg.flag=r=>(r[flagSymbol]=!0,r),arg.COUNT=arg.flag((r,e,t)=>(t||0)+1),arg.ArgError=ArgError,module.exports=arg;