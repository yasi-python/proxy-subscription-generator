"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _tokenizer=require("./parser/tokenizer"),_types=require("./parser/tokenizer/types");function identifyShadowedGlobals(e,o,n){hasShadowedGlobals(e,n)&&markShadowedGlobals(e,o,n)}function hasShadowedGlobals(e,o){for(const n of e.tokens)if(n.type===_types.TokenType.name&&!n.isType&&_tokenizer.isNonTopLevelDeclaration.call(void 0,n)&&o.has(e.identifierNameForToken(n)))return!0;return!1}function markShadowedGlobals(e,o,n){const t=[];let r=o.length-1;for(let a=e.tokens.length-1;;a--){for(;t.length>0&&t[t.length-1].startTokenIndex===a+1;)t.pop();for(;r>=0&&o[r].endTokenIndex===a+1;)t.push(o[r]),r--;if(a<0)break;const s=e.tokens[a],i=e.identifierNameForToken(s);if(t.length>1&&!s.isType&&s.type===_types.TokenType.name&&n.has(i))if(_tokenizer.isBlockScopedDeclaration.call(void 0,s))markShadowedForScope(t[t.length-1],e,i);else if(_tokenizer.isFunctionScopedDeclaration.call(void 0,s)){let o=t.length-1;for(;o>0&&!t[o].isFunctionScope;)o--;if(o<0)throw new Error("Did not find parent function scope.");markShadowedForScope(t[o],e,i)}}if(t.length>0)throw new Error("Expected empty scope stack after processing file.")}function markShadowedForScope(e,o,n){for(let t=e.startTokenIndex;t<e.endTokenIndex;t++){const e=o.tokens[t];e.type!==_types.TokenType.name&&e.type!==_types.TokenType.jsxName||o.identifierNameForToken(e)!==n||(e.shadowsGlobal=!0)}}exports.default=identifyShadowedGlobals,exports.hasShadowedGlobals=hasShadowedGlobals;