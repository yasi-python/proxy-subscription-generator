import{eat,finishToken,getTokenFromCode,IdentifierRole,JSXRole,match,next,skipSpace,Token}from"../../tokenizer/index";import{TokenType as tt}from"../../tokenizer/types";import{input,isTypeScriptEnabled,state}from"../../traverser/base";import{parseExpression,parseMaybeAssign}from"../../traverser/expression";import{expect,unexpected}from"../../traverser/util";import{charCodes}from"../../util/charcodes";import{IS_IDENTIFIER_CHAR,IS_IDENTIFIER_START}from"../../util/identifier";import{tsTryParseJSXTypeArgument}from"../typescript";function jsxReadToken(){let e=!1,t=!1;for(;;){if(state.pos>=input.length)return void unexpected("Unterminated JSX contents");const s=input.charCodeAt(state.pos);if(s===charCodes.lessThan||s===charCodes.leftCurlyBrace)return state.pos===state.start?s===charCodes.lessThan?(state.pos++,void finishToken(tt.jsxTagStart)):void getTokenFromCode(s):void finishToken(e&&!t?tt.jsxEmptyText:tt.jsxText);s===charCodes.lineFeed?e=!0:s!==charCodes.space&&s!==charCodes.carriageReturn&&s!==charCodes.tab&&(t=!0),state.pos++}}function jsxReadString(e){for(state.pos++;;){if(state.pos>=input.length)return void unexpected("Unterminated string constant");if(input.charCodeAt(state.pos)===e){state.pos++;break}state.pos++}finishToken(tt.string)}function jsxReadWord(){let e;do{if(state.pos>input.length)return void unexpected("Unexpectedly reached the end of input.");e=input.charCodeAt(++state.pos)}while(IS_IDENTIFIER_CHAR[e]||e===charCodes.dash);finishToken(tt.jsxName)}function jsxParseIdentifier(){nextJSXTagToken()}function jsxParseNamespacedName(e){jsxParseIdentifier(),eat(tt.colon)?jsxParseIdentifier():state.tokens[state.tokens.length-1].identifierRole=e}function jsxParseElementName(){const e=state.tokens.length;jsxParseNamespacedName(IdentifierRole.Access);let t=!1;for(;match(tt.dot);)t=!0,nextJSXTagToken(),jsxParseIdentifier();if(!t){const t=state.tokens[e],s=input.charCodeAt(t.start);s>=charCodes.lowercaseA&&s<=charCodes.lowercaseZ&&(t.identifierRole=null)}}function jsxParseAttributeValue(){switch(state.type){case tt.braceL:return next(),parseExpression(),void nextJSXTagToken();case tt.jsxTagStart:return jsxParseElement(),void nextJSXTagToken();case tt.string:return void nextJSXTagToken();default:unexpected("JSX value should be either an expression or a quoted JSX text")}}function jsxParseSpreadChild(){expect(tt.ellipsis),parseExpression()}function jsxParseOpeningElement(e){if(match(tt.jsxTagEnd))return!1;jsxParseElementName(),isTypeScriptEnabled&&tsTryParseJSXTypeArgument();let t=!1;for(;!match(tt.slash)&&!match(tt.jsxTagEnd)&&!state.error;)eat(tt.braceL)?(t=!0,expect(tt.ellipsis),parseMaybeAssign(),nextJSXTagToken()):(t&&state.end-state.start===3&&input.charCodeAt(state.start)===charCodes.lowercaseK&&input.charCodeAt(state.start+1)===charCodes.lowercaseE&&input.charCodeAt(state.start+2)===charCodes.lowercaseY&&(state.tokens[e].jsxRole=JSXRole.KeyAfterPropSpread),jsxParseNamespacedName(IdentifierRole.ObjectKey),match(tt.eq)&&(nextJSXTagToken(),jsxParseAttributeValue()));const s=match(tt.slash);return s&&nextJSXTagToken(),s}function jsxParseClosingElement(){match(tt.jsxTagEnd)||jsxParseElementName()}function jsxParseElementAt(){const e=state.tokens.length-1;state.tokens[e].jsxRole=JSXRole.NoChildren;let t=0;if(!jsxParseOpeningElement(e))for(nextJSXExprToken();;)switch(state.type){case tt.jsxTagStart:if(nextJSXTagToken(),match(tt.slash))return nextJSXTagToken(),jsxParseClosingElement(),void(state.tokens[e].jsxRole!==JSXRole.KeyAfterPropSpread&&(1===t?state.tokens[e].jsxRole=JSXRole.OneChild:t>1&&(state.tokens[e].jsxRole=JSXRole.StaticChildren)));t++,jsxParseElementAt(),nextJSXExprToken();break;case tt.jsxText:t++,nextJSXExprToken();break;case tt.jsxEmptyText:nextJSXExprToken();break;case tt.braceL:next(),match(tt.ellipsis)?(jsxParseSpreadChild(),nextJSXExprToken(),t+=2):(match(tt.braceR)||(t++,parseExpression()),nextJSXExprToken());break;default:return void unexpected()}}export function jsxParseElement(){nextJSXTagToken(),jsxParseElementAt()}export function nextJSXTagToken(){state.tokens.push(new Token),skipSpace(),state.start=state.pos;const e=input.charCodeAt(state.pos);if(IS_IDENTIFIER_START[e])jsxReadWord();else if(e===charCodes.quotationMark||e===charCodes.apostrophe)jsxReadString(e);else switch(++state.pos,e){case charCodes.greaterThan:finishToken(tt.jsxTagEnd);break;case charCodes.lessThan:finishToken(tt.jsxTagStart);break;case charCodes.slash:finishToken(tt.slash);break;case charCodes.equalsTo:finishToken(tt.eq);break;case charCodes.leftCurlyBrace:finishToken(tt.braceL);break;case charCodes.dot:finishToken(tt.dot);break;case charCodes.colon:finishToken(tt.colon);break;default:unexpected()}}function nextJSXExprToken(){state.tokens.push(new Token),state.start=state.pos,jsxReadToken()}