import{eat,finishToken,lookaheadTypeAndKeyword,match,nextTokenStart}from"../tokenizer/index";import{formatTokenType,TokenType as tt}from"../tokenizer/types";import{charCodes}from"../util/charcodes";import{input,state}from"./base";export function isContextual(e){return state.contextualKeyword===e}export function isLookaheadContextual(e){const t=lookaheadTypeAndKeyword();return t.type===tt.name&&t.contextualKeyword===e}export function eatContextual(e){return state.contextualKeyword===e&&eat(tt.name)}export function expectContextual(e){eatContextual(e)||unexpected()}export function canInsertSemicolon(){return match(tt.eof)||match(tt.braceR)||hasPrecedingLineBreak()}export function hasPrecedingLineBreak(){const e=state.tokens[state.tokens.length-1];for(let t=e?e.end:0;t<state.start;t++){const e=input.charCodeAt(t);if(e===charCodes.lineFeed||e===charCodes.carriageReturn||8232===e||8233===e)return!0}return!1}export function hasFollowingLineBreak(){const e=nextTokenStart();for(let t=state.end;t<e;t++){const e=input.charCodeAt(t);if(e===charCodes.lineFeed||e===charCodes.carriageReturn||8232===e||8233===e)return!0}return!1}export function isLineTerminator(){return eat(tt.semi)||canInsertSemicolon()}export function semicolon(){isLineTerminator()||unexpected('Unexpected token, expected ";"')}export function expect(e){eat(e)||unexpected(`Unexpected token, expected "${formatTokenType(e)}"`)}export function unexpected(e="Unexpected token",t=state.start){if(state.error)return;const n=new SyntaxError(e);n.pos=t,state.error=n,state.pos=input.length,finishToken(tt.eof)}