import{flowParseArrow,flowParseFunctionBodyAndFinish,flowParseMaybeAssign,flowParseSubscript,flowParseSubscripts,flowParseVariance,flowStartParseAsyncArrowFromCallExpression,flowStartParseNewArguments,flowStartParseObjPropValue}from"../plugins/flow";import{jsxParseElement}from"../plugins/jsx/index";import{typedParseConditional,typedParseParenItem}from"../plugins/types";import{tsParseArrow,tsParseFunctionBodyAndFinish,tsParseMaybeAssign,tsParseSubscript,tsParseType,tsParseTypeAssertion,tsStartParseAsyncArrowFromCallExpression,tsStartParseObjPropValue}from"../plugins/typescript";import{eat,IdentifierRole,lookaheadCharCode,lookaheadType,match,next,nextTemplateToken,popTypeContext,pushTypeContext,rescan_gt,retokenizeSlashAsRegex}from"../tokenizer/index";import{ContextualKeyword}from"../tokenizer/keywords";import{Scope}from"../tokenizer/state";import{TokenType,TokenType as tt}from"../tokenizer/types";import{charCodes}from"../util/charcodes";import{IS_IDENTIFIER_START}from"../util/identifier";import{getNextContextId,isFlowEnabled,isJSXEnabled,isTypeScriptEnabled,state}from"./base";import{markPriorBindingIdentifier,parseBindingIdentifier,parseMaybeDefault,parseRest,parseSpread}from"./lval";import{parseBlock,parseBlockBody,parseClass,parseDecorators,parseFunction,parseFunctionParams}from"./statement";import{canInsertSemicolon,eatContextual,expect,expectContextual,hasFollowingLineBreak,hasPrecedingLineBreak,isContextual,unexpected}from"./util";export class StopState{constructor(t){this.stop=t}}export function parseExpression(t=!1){if(parseMaybeAssign(t),match(tt.comma))for(;eat(tt.comma);)parseMaybeAssign(t)}export function parseMaybeAssign(t=!1,e=!1){return isTypeScriptEnabled?tsParseMaybeAssign(t,e):isFlowEnabled?flowParseMaybeAssign(t,e):baseParseMaybeAssign(t,e)}export function baseParseMaybeAssign(t,e){if(match(tt._yield))return parseYield(),!1;(match(tt.parenL)||match(tt.name)||match(tt._yield))&&(state.potentialArrowAt=state.start);const s=parseMaybeConditional(t);return e&&parseParenItem(),state.type&TokenType.IS_ASSIGN?(next(),parseMaybeAssign(t),!1):s}function parseMaybeConditional(t){return!!parseExprOps(t)||(parseConditional(t),!1)}function parseConditional(t){isTypeScriptEnabled||isFlowEnabled?typedParseConditional(t):baseParseConditional(t)}export function baseParseConditional(t){eat(tt.question)&&(parseMaybeAssign(),expect(tt.colon),parseMaybeAssign(t))}function parseExprOps(t){const e=state.tokens.length;return!!parseMaybeUnary()||(parseExprOp(e,-1,t),!1)}function parseExprOp(t,e,s){if(isTypeScriptEnabled&&(tt._in&TokenType.PRECEDENCE_MASK)>e&&!hasPrecedingLineBreak()&&(eatContextual(ContextualKeyword._as)||eatContextual(ContextualKeyword._satisfies))){const a=pushTypeContext(1);return tsParseType(),popTypeContext(a),rescan_gt(),void parseExprOp(t,e,s)}const a=state.type&TokenType.PRECEDENCE_MASK;if(a>0&&(!s||!match(tt._in))&&a>e){const r=state.type;next(),r===tt.nullishCoalescing&&(state.tokens[state.tokens.length-1].nullishStartIndex=t);const n=state.tokens.length;parseMaybeUnary(),parseExprOp(n,r&TokenType.IS_RIGHT_ASSOCIATIVE?a-1:a,s),r===tt.nullishCoalescing&&(state.tokens[t].numNullishCoalesceStarts++,state.tokens[state.tokens.length-1].numNullishCoalesceEnds++),parseExprOp(t,e,s)}}export function parseMaybeUnary(){if(isTypeScriptEnabled&&!isJSXEnabled&&eat(tt.lessThan))return tsParseTypeAssertion(),!1;if(isContextual(ContextualKeyword._module)&&lookaheadCharCode()===charCodes.leftCurlyBrace&&!hasFollowingLineBreak())return parseModuleExpression(),!1;if(state.type&TokenType.IS_PREFIX)return next(),parseMaybeUnary(),!1;if(parseExprSubscripts())return!0;for(;state.type&TokenType.IS_POSTFIX&&!canInsertSemicolon();)state.type===tt.preIncDec&&(state.type=tt.postIncDec),next();return!1}export function parseExprSubscripts(){const t=state.tokens.length;return!!parseExprAtom()||(parseSubscripts(t),state.tokens.length>t&&state.tokens[t].isOptionalChainStart&&(state.tokens[state.tokens.length-1].isOptionalChainEnd=!0),!1)}function parseSubscripts(t,e=!1){isFlowEnabled?flowParseSubscripts(t,e):baseParseSubscripts(t,e)}export function baseParseSubscripts(t,e=!1){const s=new StopState(!1);do{parseSubscript(t,e,s)}while(!s.stop&&!state.error)}function parseSubscript(t,e,s){isTypeScriptEnabled?tsParseSubscript(t,e,s):isFlowEnabled?flowParseSubscript(t,e,s):baseParseSubscript(t,e,s)}export function baseParseSubscript(t,e,s){if(!e&&eat(tt.doubleColon))parseNoCallExpr(),s.stop=!0,parseSubscripts(t,e);else if(match(tt.questionDot)){if(state.tokens[t].isOptionalChainStart=!0,e&&lookaheadType()===tt.parenL)return void(s.stop=!0);next(),state.tokens[state.tokens.length-1].subscriptStartIndex=t,eat(tt.bracketL)?(parseExpression(),expect(tt.bracketR)):eat(tt.parenL)?parseCallExpressionArguments():parseMaybePrivateName()}else if(eat(tt.dot))state.tokens[state.tokens.length-1].subscriptStartIndex=t,parseMaybePrivateName();else if(eat(tt.bracketL))state.tokens[state.tokens.length-1].subscriptStartIndex=t,parseExpression(),expect(tt.bracketR);else if(!e&&match(tt.parenL))if(atPossibleAsync()){const e=state.snapshot(),a=state.tokens.length;next(),state.tokens[state.tokens.length-1].subscriptStartIndex=t;const r=getNextContextId();state.tokens[state.tokens.length-1].contextId=r,parseCallExpressionArguments(),state.tokens[state.tokens.length-1].contextId=r,shouldParseAsyncArrow()&&(state.restoreFromSnapshot(e),s.stop=!0,state.scopeDepth++,parseFunctionParams(),parseAsyncArrowFromCallExpression(a))}else{next(),state.tokens[state.tokens.length-1].subscriptStartIndex=t;const e=getNextContextId();state.tokens[state.tokens.length-1].contextId=e,parseCallExpressionArguments(),state.tokens[state.tokens.length-1].contextId=e}else match(tt.backQuote)?parseTemplate():s.stop=!0}export function atPossibleAsync(){return state.tokens[state.tokens.length-1].contextualKeyword===ContextualKeyword._async&&!canInsertSemicolon()}export function parseCallExpressionArguments(){let t=!0;for(;!eat(tt.parenR)&&!state.error;){if(t)t=!1;else if(expect(tt.comma),eat(tt.parenR))break;parseExprListItem(!1)}}function shouldParseAsyncArrow(){return match(tt.colon)||match(tt.arrow)}function parseAsyncArrowFromCallExpression(t){isTypeScriptEnabled?tsStartParseAsyncArrowFromCallExpression():isFlowEnabled&&flowStartParseAsyncArrowFromCallExpression(),expect(tt.arrow),parseArrowExpression(t)}function parseNoCallExpr(){const t=state.tokens.length;parseExprAtom(),parseSubscripts(t,!0)}export function parseExprAtom(){if(eat(tt.modulo))return parseIdentifier(),!1;if(match(tt.jsxText)||match(tt.jsxEmptyText))return parseLiteral(),!1;if(match(tt.lessThan)&&isJSXEnabled)return state.type=tt.jsxTagStart,jsxParseElement(),next(),!1;const t=state.potentialArrowAt===state.start;switch(state.type){case tt.slash:case tt.assign:retokenizeSlashAsRegex();case tt._super:case tt._this:case tt.regexp:case tt.num:case tt.bigint:case tt.decimal:case tt.string:case tt._null:case tt._true:case tt._false:return next(),!1;case tt._import:return next(),match(tt.dot)&&(state.tokens[state.tokens.length-1].type=tt.name,next(),parseIdentifier()),!1;case tt.name:{const e=state.tokens.length,s=state.start,a=state.contextualKeyword;return parseIdentifier(),a===ContextualKeyword._await?(parseAwait(),!1):a===ContextualKeyword._async&&match(tt._function)&&!canInsertSemicolon()?(next(),parseFunction(s,!1),!1):t&&a===ContextualKeyword._async&&!canInsertSemicolon()&&match(tt.name)?(state.scopeDepth++,parseBindingIdentifier(!1),expect(tt.arrow),parseArrowExpression(e),!0):match(tt._do)&&!canInsertSemicolon()?(next(),parseBlock(),!1):t&&!canInsertSemicolon()&&match(tt.arrow)?(state.scopeDepth++,markPriorBindingIdentifier(!1),expect(tt.arrow),parseArrowExpression(e),!0):(state.tokens[state.tokens.length-1].identifierRole=IdentifierRole.Access,!1)}case tt._do:return next(),parseBlock(),!1;case tt.parenL:return parseParenAndDistinguishExpression(t);case tt.bracketL:return next(),parseExprList(tt.bracketR,!0),!1;case tt.braceL:return parseObj(!1,!1),!1;case tt._function:return parseFunctionExpression(),!1;case tt.at:parseDecorators();case tt._class:return parseClass(!1),!1;case tt._new:return parseNew(),!1;case tt.backQuote:return parseTemplate(),!1;case tt.doubleColon:return next(),parseNoCallExpr(),!1;case tt.hash:{const t=lookaheadCharCode();return IS_IDENTIFIER_START[t]||t===charCodes.backslash?parseMaybePrivateName():next(),!1}default:return unexpected(),!1}}function parseMaybePrivateName(){eat(tt.hash),parseIdentifier()}function parseFunctionExpression(){const t=state.start;parseIdentifier(),eat(tt.dot)&&parseIdentifier(),parseFunction(t,!1)}export function parseLiteral(){next()}export function parseParenExpression(){expect(tt.parenL),parseExpression(),expect(tt.parenR)}function parseParenAndDistinguishExpression(t){const e=state.snapshot(),s=state.tokens.length;expect(tt.parenL);let a=!0;for(;!match(tt.parenR)&&!state.error;){if(a)a=!1;else if(expect(tt.comma),match(tt.parenR))break;if(match(tt.ellipsis)){parseRest(!1),parseParenItem();break}parseMaybeAssign(!1,!0)}if(expect(tt.parenR),t&&shouldParseArrow()){if(parseArrow())return state.restoreFromSnapshot(e),state.scopeDepth++,parseFunctionParams(),parseArrow(),parseArrowExpression(s),!state.error||(state.restoreFromSnapshot(e),parseParenAndDistinguishExpression(!1),!1)}return!1}function shouldParseArrow(){return match(tt.colon)||!canInsertSemicolon()}export function parseArrow(){return isTypeScriptEnabled?tsParseArrow():isFlowEnabled?flowParseArrow():eat(tt.arrow)}function parseParenItem(){(isTypeScriptEnabled||isFlowEnabled)&&typedParseParenItem()}function parseNew(){expect(tt._new),eat(tt.dot)?parseIdentifier():(parseNewCallee(),isFlowEnabled&&flowStartParseNewArguments(),eat(tt.parenL)&&parseExprList(tt.parenR))}function parseNewCallee(){parseNoCallExpr(),eat(tt.questionDot)}export function parseTemplate(){for(nextTemplateToken(),nextTemplateToken();!match(tt.backQuote)&&!state.error;)expect(tt.dollarBraceL),parseExpression(),nextTemplateToken(),nextTemplateToken();next()}export function parseObj(t,e){const s=getNextContextId();let a=!0;for(next(),state.tokens[state.tokens.length-1].contextId=s;!eat(tt.braceR)&&!state.error;){if(a)a=!1;else if(expect(tt.comma),eat(tt.braceR))break;let r=!1;if(match(tt.ellipsis)){const s=state.tokens.length;if(parseSpread(),t&&(state.tokens.length===s+2&&markPriorBindingIdentifier(e),eat(tt.braceR)))break;continue}t||(r=eat(tt.star)),!t&&isContextual(ContextualKeyword._async)?(r&&unexpected(),parseIdentifier(),match(tt.colon)||match(tt.parenL)||match(tt.braceR)||match(tt.eq)||match(tt.comma)||(match(tt.star)&&(next(),r=!0),parsePropertyName(s))):parsePropertyName(s),parseObjPropValue(t,e,s)}state.tokens[state.tokens.length-1].contextId=s}function isGetterOrSetterMethod(t){return!t&&(match(tt.string)||match(tt.num)||match(tt.bracketL)||match(tt.name)||!!(state.type&TokenType.IS_KEYWORD))}function parseObjectMethod(t,e){const s=state.start;return match(tt.parenL)?(t&&unexpected(),parseMethod(s,!1),!0):!!isGetterOrSetterMethod(t)&&(parsePropertyName(e),parseMethod(s,!1),!0)}function parseObjectProperty(t,e){if(eat(tt.colon))return void(t?parseMaybeDefault(e):parseMaybeAssign(!1));let s;s=t?0===state.scopeDepth?IdentifierRole.ObjectShorthandTopLevelDeclaration:e?IdentifierRole.ObjectShorthandBlockScopedDeclaration:IdentifierRole.ObjectShorthandFunctionScopedDeclaration:IdentifierRole.ObjectShorthand,state.tokens[state.tokens.length-1].identifierRole=s,parseMaybeDefault(e,!0)}function parseObjPropValue(t,e,s){isTypeScriptEnabled?tsStartParseObjPropValue():isFlowEnabled&&flowStartParseObjPropValue();parseObjectMethod(t,s)||parseObjectProperty(t,e)}export function parsePropertyName(t){isFlowEnabled&&flowParseVariance(),eat(tt.bracketL)?(state.tokens[state.tokens.length-1].contextId=t,parseMaybeAssign(),expect(tt.bracketR),state.tokens[state.tokens.length-1].contextId=t):(match(tt.num)||match(tt.string)||match(tt.bigint)||match(tt.decimal)?parseExprAtom():parseMaybePrivateName(),state.tokens[state.tokens.length-1].identifierRole=IdentifierRole.ObjectKey,state.tokens[state.tokens.length-1].contextId=t)}export function parseMethod(t,e){const s=getNextContextId();state.scopeDepth++;const a=state.tokens.length;parseFunctionParams(e,s),parseFunctionBodyAndFinish(t,s);const r=state.tokens.length;state.scopes.push(new Scope(a,r,!0)),state.scopeDepth--}export function parseArrowExpression(t){parseFunctionBody(!0);const e=state.tokens.length;state.scopes.push(new Scope(t,e,!0)),state.scopeDepth--}export function parseFunctionBodyAndFinish(t,e=0){isTypeScriptEnabled?tsParseFunctionBodyAndFinish(t,e):isFlowEnabled?flowParseFunctionBodyAndFinish(e):parseFunctionBody(!1,e)}export function parseFunctionBody(t,e=0){t&&!match(tt.braceL)?parseMaybeAssign():parseBlock(!0,e)}function parseExprList(t,e=!1){let s=!0;for(;!eat(t)&&!state.error;){if(s)s=!1;else if(expect(tt.comma),eat(t))break;parseExprListItem(e)}}function parseExprListItem(t){t&&match(tt.comma)||(match(tt.ellipsis)?(parseSpread(),parseParenItem()):match(tt.question)?next():parseMaybeAssign(!1,!0))}export function parseIdentifier(){next(),state.tokens[state.tokens.length-1].type=tt.name}function parseAwait(){parseMaybeUnary()}function parseYield(){next(),match(tt.semi)||canInsertSemicolon()||(eat(tt.star),parseMaybeAssign())}function parseModuleExpression(){expectContextual(ContextualKeyword._module),expect(tt.braceL),parseBlockBody(tt.braceR)}