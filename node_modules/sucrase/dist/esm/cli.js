import commander from"commander";import{glob}from"glob";import{exists,mkdir,readdir,readFile,stat,writeFile}from"mz/fs";import{dirname,join,relative}from"path";import{transform}from"./index";export default function run(){commander.description("Sucrase: super-fast Babel alternative.").usage("[options] <srcDir>").option("-d, --out-dir <out>","Compile an input directory of modules into an output directory.").option("-p, --project <dir>","Compile a TypeScript project, will read from tsconfig.json in <dir>").option("--out-extension <extension>","File extension to use for all output files.","js").option("--exclude-dirs <paths>","Names of directories that should not be traversed.").option("-q, --quiet","Don't print the names of converted files.").option("-t, --transforms <transforms>","Comma-separated list of transforms to run.").option("--disable-es-transforms","Opt out of all ES syntax transforms.").option("--jsx-runtime <string>","Transformation mode for the JSX transform.").option("--production","Disable debugging information from JSX in output.").option("--jsx-import-source <string>","Automatic JSX transform import path prefix, defaults to `React.Fragment`.").option("--jsx-pragma <string>","Classic JSX transform element creation function, defaults to `React.createElement`.").option("--jsx-fragment-pragma <string>","Classic JSX transform fragment component, defaults to `React.Fragment`.").option("--keep-unused-imports","Disable automatic removal of type-only imports/exports.").option("--preserve-dynamic-import","Don't transpile dynamic import() to require.").option("--inject-create-require-for-import-require","Use `createRequire` when transpiling TS `import = require` to ESM.").option("--enable-legacy-typescript-module-interop","Use default TypeScript ESM/CJS interop strategy.").option("--enable-legacy-babel5-module-interop","Use Babel 5 ESM/CJS interop strategy.").parse(process.argv),commander.project?(commander.outDir||commander.transforms||commander.args[0]||commander.enableLegacyTypescriptModuleInterop)&&(console.error("If TypeScript project is specified, out directory, transforms, source directory, and --enable-legacy-typescript-module-interop may not be specified."),process.exit(1)):(commander.outDir||(console.error("Out directory is required"),process.exit(1)),commander.transforms||(console.error("Transforms option is required."),process.exit(1)),commander.args[0]||(console.error("Source directory is required."),process.exit(1))),buildDirectory({outDirPath:commander.outDir,srcDirPath:commander.args[0],project:commander.project,outExtension:commander.outExtension,excludeDirs:commander.excludeDirs?commander.excludeDirs.split(","):[],quiet:commander.quiet,sucraseOptions:{transforms:commander.transforms?commander.transforms.split(","):[],disableESTransforms:commander.disableEsTransforms,jsxRuntime:commander.jsxRuntime,production:commander.production,jsxImportSource:commander.jsxImportSource,jsxPragma:commander.jsxPragma||"React.createElement",jsxFragmentPragma:commander.jsxFragmentPragma||"React.Fragment",keepUnusedImports:commander.keepUnusedImports,preserveDynamicImport:commander.preserveDynamicImport,injectCreateRequireForImportRequire:commander.injectCreateRequireForImportRequire,enableLegacyTypeScriptModuleInterop:commander.enableLegacyTypescriptModuleInterop,enableLegacyBabel5ModuleInterop:commander.enableLegacyBabel5ModuleInterop}}).catch(e=>{process.exitCode=1,console.error(e)})}async function findFiles(e){const o=e.outDirPath,r=e.srcDirPath,t=e.sucraseOptions.transforms.includes("typescript")?[".ts",".tsx"]:[".js",".jsx"];await exists(o)||await mkdir(o);const i=[];for(const s of await readdir(r)){if(["node_modules",".git"].includes(s)||e.excludeDirs.includes(s))continue;const n=join(r,s),a=join(o,s);if((await stat(n)).isDirectory()){const o={...e};o.srcDirPath=n,o.outDirPath=a;const r=await findFiles(o);i.push(...r)}else if(t.some(e=>n.endsWith(e))){const o=a.replace(/\.\w+$/,`.${e.outExtension}`);i.push({srcPath:n,outPath:o})}}return i}async function runGlob(e){const o=join(e.project,"tsconfig.json");let r;try{r=await readFile(o,"utf8")}catch(o){console.error("Could not find project tsconfig.json"),console.error(`  --project=${e.project}`),console.error(o),process.exit(1)}const t=JSON.parse(r),i=[],s=t.files,n=t.include,a=join(process.cwd(),e.project),c=[];if(await exists(e.outDirPath)||await mkdir(e.outDirPath),s)for(const o of s){if(o.endsWith(".d.ts"))continue;if(!o.endsWith(".ts")&&!o.endsWith(".js"))continue;const r=join(a,o),t=join(e.outDirPath,o).replace(/\.\w+$/,`.${e.outExtension}`),s=dirname(t);c.includes(s)||c.push(s),i.push({srcPath:r,outPath:t})}if(n)for(const o of n){const r=await glob(join(a,o));for(const o of r){if(!o.endsWith(".ts")&&!o.endsWith(".js"))continue;if(o.endsWith(".d.ts"))continue;const r=relative(a,o),t=join(e.outDirPath,r).replace(/\.\w+$/,`.${e.outExtension}`),s=dirname(t);c.includes(s)||c.push(s),i.push({srcPath:o,outPath:t})}}for(const e of c)await exists(e)||await mkdir(e);return i}async function updateOptionsFromProject(e){const o=join(e.project,"tsconfig.json");let r;try{r=await readFile(o,"utf8")}catch(o){console.error("Could not find project tsconfig.json"),console.error(`  --project=${e.project}`),console.error(o),process.exit(1)}const t=JSON.parse(r),i=e.sucraseOptions;i.transforms.includes("typescript")||i.transforms.push("typescript");const s=t.compilerOptions;s.outDir&&(e.outDirPath=join(process.cwd(),e.project,s.outDir)),!0!==s.esModuleInterop&&(i.enableLegacyTypeScriptModuleInterop=!0),"commonjs"===s.module&&(i.transforms.includes("imports")||i.transforms.push("imports"))}async function buildDirectory(e){let o;e.outDirPath&&e.srcDirPath?o=await findFiles(e):e.project?(await updateOptionsFromProject(e),o=await runGlob(e)):(console.error("Project or Source directory required."),process.exit(1));for(const r of o)await buildFile(r.srcPath,r.outPath,e)}async function buildFile(e,o,r){r.quiet||console.log(`${e} -> ${o}`);const t=(await readFile(e)).toString(),i=transform(t,{...r.sucraseOptions,filePath:e}).code;await writeFile(o,i)}