import{isBlockScopedDeclaration,isFunctionScopedDeclaration,isNonTopLevelDeclaration}from"./parser/tokenizer";import{TokenType as tt}from"./parser/tokenizer/types";export default function identifyShadowedGlobals(e,o,t){hasShadowedGlobals(e,t)&&markShadowedGlobals(e,o,t)}export function hasShadowedGlobals(e,o){for(const t of e.tokens)if(t.type===tt.name&&!t.isType&&isNonTopLevelDeclaration(t)&&o.has(e.identifierNameForToken(t)))return!0;return!1}function markShadowedGlobals(e,o,t){const n=[];let r=o.length-1;for(let a=e.tokens.length-1;;a--){for(;n.length>0&&n[n.length-1].startTokenIndex===a+1;)n.pop();for(;r>=0&&o[r].endTokenIndex===a+1;)n.push(o[r]),r--;if(a<0)break;const i=e.tokens[a],s=e.identifierNameForToken(i);if(n.length>1&&!i.isType&&i.type===tt.name&&t.has(s))if(isBlockScopedDeclaration(i))markShadowedForScope(n[n.length-1],e,s);else if(isFunctionScopedDeclaration(i)){let o=n.length-1;for(;o>0&&!n[o].isFunctionScope;)o--;if(o<0)throw new Error("Did not find parent function scope.");markShadowedForScope(n[o],e,s)}}if(n.length>0)throw new Error("Expected empty scope stack after processing file.")}function markShadowedForScope(e,o,t){for(let n=e.startTokenIndex;n<e.endTokenIndex;n++){const e=o.tokens[n];e.type!==tt.name&&e.type!==tt.jsxName||o.identifierNameForToken(e)!==t||(e.shadowsGlobal=!0)}}