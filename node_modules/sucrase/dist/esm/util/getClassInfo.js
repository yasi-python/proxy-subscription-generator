import{ContextualKeyword}from"../parser/tokenizer/keywords";import{TokenType as tt}from"../parser/tokenizer/types";export default function getClassInfo(e,t,n,r){const o=t.snapshot(),s=processClassHeader(t);let c=[];const a=[],i=[];let l=null;const u=[],x=[],d=t.currentToken().contextId;if(null==d)throw new Error("Expected non-null class context ID on class open-brace.");for(t.nextToken();!t.matchesContextIdAndLabel(tt.braceR,d);)if(t.matchesContextual(ContextualKeyword._constructor)&&!t.currentToken().isType)({constructorInitializerStatements:c,constructorInsertPos:l}=processConstructor(t));else if(t.matches1(tt.semi))r||x.push({start:t.currentIndex(),end:t.currentIndex()+1}),t.nextToken();else if(t.currentToken().isType)t.nextToken();else{const o=t.currentIndex();let s=!1,p=!1,k=!1;for(;isAccessModifier(t.currentToken());)t.matches1(tt._static)&&(s=!0),t.matches1(tt.hash)&&(p=!0),(t.matches1(tt._declare)||t.matches1(tt._abstract))&&(k=!0),t.nextToken();if(s&&t.matches1(tt.braceL)){skipToNextClassElement(t,d);continue}if(p){skipToNextClassElement(t,d);continue}if(t.matchesContextual(ContextualKeyword._constructor)&&!t.currentToken().isType){({constructorInitializerStatements:c,constructorInsertPos:l}=processConstructor(t));continue}const T=t.currentIndex();if(skipFieldName(t),t.matches1(tt.lessThan)||t.matches1(tt.parenL)){skipToNextClassElement(t,d);continue}for(;t.currentToken().isType;)t.nextToken();if(t.matches1(tt.eq)){const r=t.currentIndex(),o=t.currentToken().rhsEndIndex;if(null==o)throw new Error("Expected rhsEndIndex on class field assignment.");for(t.nextToken();t.currentIndex()<o;)e.processToken();let c;s?(c=n.claimFreeName("__initStatic"),i.push(c)):(c=n.claimFreeName("__init"),a.push(c)),u.push({initializerName:c,equalsIndex:r,start:T,end:t.currentIndex()})}else r&&!k||x.push({start:o,end:t.currentIndex()})}return t.restoreToSnapshot(o),r?{headerInfo:s,constructorInitializerStatements:c,instanceInitializerNames:[],staticInitializerNames:[],constructorInsertPos:l,fields:[],rangesToRemove:x}:{headerInfo:s,constructorInitializerStatements:c,instanceInitializerNames:a,staticInitializerNames:i,constructorInsertPos:l,fields:u,rangesToRemove:x}}function skipToNextClassElement(e,t){for(e.nextToken();e.currentToken().contextId!==t;)e.nextToken();for(;isAccessModifier(e.tokenAtRelativeIndex(-1));)e.previousToken()}function processClassHeader(e){const t=e.currentToken(),n=t.contextId;if(null==n)throw new Error("Expected context ID on class token.");const r=t.isExpression;if(null==r)throw new Error("Expected isExpression on class token.");let o=null,s=!1;for(e.nextToken(),e.matches1(tt.name)&&(o=e.identifierName());!e.matchesContextIdAndLabel(tt.braceL,n);)e.matches1(tt._extends)&&!e.currentToken().isType&&(s=!0),e.nextToken();return{isExpression:r,className:o,hasSuperclass:s}}function processConstructor(e){const t=[];e.nextToken();const n=e.currentToken().contextId;if(null==n)throw new Error("Expected context ID on open-paren starting constructor params.");for(;!e.matchesContextIdAndLabel(tt.parenR,n);)if(e.currentToken().contextId===n){if(e.nextToken(),isAccessModifier(e.currentToken())){for(e.nextToken();isAccessModifier(e.currentToken());)e.nextToken();const n=e.currentToken();if(n.type!==tt.name)throw new Error("Expected identifier after access modifiers in constructor arg.");const r=e.identifierNameForToken(n);t.push(`this.${r} = ${r}`)}}else e.nextToken();for(e.nextToken();e.currentToken().isType;)e.nextToken();let r=e.currentIndex(),o=!1;for(;!e.matchesContextIdAndLabel(tt.braceR,n);){if(!o&&e.matches2(tt._super,tt.parenL)){e.nextToken();const t=e.currentToken().contextId;if(null==t)throw new Error("Expected a context ID on the super call");for(;!e.matchesContextIdAndLabel(tt.parenR,t);)e.nextToken();r=e.currentIndex(),o=!0}e.nextToken()}return e.nextToken(),{constructorInitializerStatements:t,constructorInsertPos:r}}function isAccessModifier(e){return[tt._async,tt._get,tt._set,tt.plus,tt.minus,tt._readonly,tt._static,tt._public,tt._private,tt._protected,tt._override,tt._abstract,tt.star,tt._declare,tt.hash].includes(e.type)}function skipFieldName(e){if(e.matches1(tt.bracketL)){const t=e.currentToken().contextId;if(null==t)throw new Error("Expected class context ID on computed name open bracket.");for(;!e.matchesContextIdAndLabel(tt.bracketR,t);)e.nextToken();e.nextToken()}else e.nextToken()}