"use strict";const taskManager=require("./managers/tasks"),async_1=require("./providers/async"),stream_1=require("./providers/stream"),sync_1=require("./providers/sync"),settings_1=require("./settings"),utils=require("./utils");async function FastGlob(t,n){assertPatternsInput(t);const e=getWorks(t,async_1.default,n),s=await Promise.all(e);return utils.array.flatten(s)}function getWorks(t,n,e){const s=[].concat(t),r=new settings_1.default(e),a=taskManager.generate(s,r),u=new n(r);return a.map(u.read,u)}function assertPatternsInput(t){if(![].concat(t).every(t=>utils.string.isString(t)&&!utils.string.isEmpty(t)))throw new TypeError("Patterns must be a string (non empty) or an array of strings")}!function(t){function n(t,n){assertPatternsInput(t);const e=getWorks(t,sync_1.default,n);return utils.array.flatten(e)}function e(t,n){assertPatternsInput(t);const e=getWorks(t,stream_1.default,n);return utils.stream.merge(e)}let s,r;t.glob=t,t.globSync=n,t.globStream=e,t.async=t,t.sync=n,t.stream=e,t.generateTasks=function(t,n){assertPatternsInput(t);const e=[].concat(t),s=new settings_1.default(n);return taskManager.generate(e,s)},t.isDynamicPattern=function(t,n){assertPatternsInput(t);const e=new settings_1.default(n);return utils.pattern.isDynamicPattern(t,e)},t.escapePath=function(t){return assertPatternsInput(t),utils.path.escape(t)},t.convertPathToPattern=function(t){return assertPatternsInput(t),utils.path.convertPathToPattern(t)},function(t){t.escapePath=function(t){return assertPatternsInput(t),utils.path.escapePosixPath(t)},t.convertPathToPattern=function(t){return assertPatternsInput(t),utils.path.convertPosixPathToPattern(t)}}(s=t.posix||(t.posix={})),function(t){t.escapePath=function(t){return assertPatternsInput(t),utils.path.escapeWindowsPath(t)},t.convertPathToPattern=function(t){return assertPatternsInput(t),utils.path.convertWindowsPathToPattern(t)}}(r=t.win32||(t.win32={}))}(FastGlob||(FastGlob={})),module.exports=FastGlob;