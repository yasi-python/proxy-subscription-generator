import{Minipass}from"minipass";import{Ignore}from"./ignore.js";import{Processor}from"./processor.js";const makeIgnore=(t,s)=>"string"==typeof t?new Ignore([t],s):Array.isArray(t)?new Ignore(t,s):t;export class GlobUtil{path;patterns;opts;seen=new Set;paused=!1;aborted=!1;#t=[];#s;#i;signal;maxDepth;includeChildMatches;constructor(t,s,i){if(this.patterns=t,this.path=s,this.opts=i,this.#i=i.posix||"win32"!==i.platform?"/":"\\",this.includeChildMatches=!1!==i.includeChildMatches,(i.ignore||!this.includeChildMatches)&&(this.#s=makeIgnore(i.ignore??[],i),!this.includeChildMatches&&"function"!=typeof this.#s.add))throw new Error("cannot ignore child matches, ignore lacks add() method.");this.maxDepth=i.maxDepth||1/0,i.signal&&(this.signal=i.signal,this.signal.addEventListener("abort",()=>{this.#t.length=0}))}#e(t){return this.seen.has(t)||!!this.#s?.ignored?.(t)}#h(t){return!!this.#s?.childrenIgnored?.(t)}pause(){this.paused=!0}resume(){if(this.signal?.aborted)return;let t;for(this.paused=!1;!this.paused&&(t=this.#t.shift());)t()}onResume(t){this.signal?.aborted||(this.paused?this.#t.push(t):t())}async matchCheck(t,s){if(s&&this.opts.nodir)return;let i;if(this.opts.realpath){if(i=t.realpathCached()||await t.realpath(),!i)return;t=i}const e=t.isUnknown()||this.opts.stat?await t.lstat():t;if(this.opts.follow&&this.opts.nodir&&e?.isSymbolicLink()){const t=await e.realpath();t&&(t.isUnknown()||this.opts.stat)&&await t.lstat()}return this.matchCheckTest(e,s)}matchCheckTest(t,s){return!t||!(this.maxDepth===1/0||t.depth()<=this.maxDepth)||s&&!t.canReaddir()||this.opts.nodir&&t.isDirectory()||this.opts.nodir&&this.opts.follow&&t.isSymbolicLink()&&t.realpathCached()?.isDirectory()||this.#e(t)?void 0:t}matchCheckSync(t,s){if(s&&this.opts.nodir)return;let i;if(this.opts.realpath){if(i=t.realpathCached()||t.realpathSync(),!i)return;t=i}const e=t.isUnknown()||this.opts.stat?t.lstatSync():t;if(this.opts.follow&&this.opts.nodir&&e?.isSymbolicLink()){const t=e.realpathSync();t&&(t?.isUnknown()||this.opts.stat)&&t.lstatSync()}return this.matchCheckTest(e,s)}matchFinish(t,s){if(this.#e(t))return;if(!this.includeChildMatches&&this.#s?.add){const s=`${t.relativePosix()}/**`;this.#s.add(s)}const i=void 0===this.opts.absolute?s:this.opts.absolute;this.seen.add(t);const e=this.opts.mark&&t.isDirectory()?this.#i:"";if(this.opts.withFileTypes)this.matchEmit(t);else if(i){const s=this.opts.posix?t.fullpathPosix():t.fullpath();this.matchEmit(s+e)}else{const s=this.opts.posix?t.relativePosix():t.relative(),i=this.opts.dotRelative&&!s.startsWith(".."+this.#i)?"."+this.#i:"";this.matchEmit(s?i+s+e:"."+e)}}async match(t,s,i){const e=await this.matchCheck(t,i);e&&this.matchFinish(e,s)}matchSync(t,s,i){const e=this.matchCheckSync(t,i);e&&this.matchFinish(e,s)}walkCB(t,s,i){this.signal?.aborted&&i(),this.walkCB2(t,s,new Processor(this.opts),i)}walkCB2(t,s,i,e){if(this.#h(t))return e();if(this.signal?.aborted&&e(),this.paused)return void this.onResume(()=>this.walkCB2(t,s,i,e));i.processPatterns(t,s);let h=1;const a=()=>{0===--h&&e()};for(const[t,s,e]of i.matches.entries())this.#e(t)||(h++,this.match(t,s,e).then(()=>a()));for(const t of i.subwalkTargets()){if(this.maxDepth!==1/0&&t.depth()>=this.maxDepth)continue;h++;const s=t.readdirCached();t.calledReaddir()?this.walkCB3(t,s,i,a):t.readdirCB((s,e)=>this.walkCB3(t,e,i,a),!0)}a()}walkCB3(t,s,i,e){i=i.filterEntries(t,s);let h=1;const a=()=>{0===--h&&e()};for(const[t,s,e]of i.matches.entries())this.#e(t)||(h++,this.match(t,s,e).then(()=>a()));for(const[t,s]of i.subwalks.entries())h++,this.walkCB2(t,s,i.child(),a);a()}walkCBSync(t,s,i){this.signal?.aborted&&i(),this.walkCB2Sync(t,s,new Processor(this.opts),i)}walkCB2Sync(t,s,i,e){if(this.#h(t))return e();if(this.signal?.aborted&&e(),this.paused)return void this.onResume(()=>this.walkCB2Sync(t,s,i,e));i.processPatterns(t,s);let h=1;const a=()=>{0===--h&&e()};for(const[t,s,e]of i.matches.entries())this.#e(t)||this.matchSync(t,s,e);for(const t of i.subwalkTargets()){if(this.maxDepth!==1/0&&t.depth()>=this.maxDepth)continue;h++;const s=t.readdirSync();this.walkCB3Sync(t,s,i,a)}a()}walkCB3Sync(t,s,i,e){i=i.filterEntries(t,s);let h=1;const a=()=>{0===--h&&e()};for(const[t,s,e]of i.matches.entries())this.#e(t)||this.matchSync(t,s,e);for(const[t,s]of i.subwalks.entries())h++,this.walkCB2Sync(t,s,i.child(),a);a()}}export class GlobWalker extends GlobUtil{matches=new Set;constructor(t,s,i){super(t,s,i)}matchEmit(t){this.matches.add(t)}async walk(){if(this.signal?.aborted)throw this.signal.reason;return this.path.isUnknown()&&await this.path.lstat(),await new Promise((t,s)=>{this.walkCB(this.path,this.patterns,()=>{this.signal?.aborted?s(this.signal.reason):t(this.matches)})}),this.matches}walkSync(){if(this.signal?.aborted)throw this.signal.reason;return this.path.isUnknown()&&this.path.lstatSync(),this.walkCBSync(this.path,this.patterns,()=>{if(this.signal?.aborted)throw this.signal.reason}),this.matches}}export class GlobStream extends GlobUtil{results;constructor(t,s,i){super(t,s,i),this.results=new Minipass({signal:this.signal,objectMode:!0}),this.results.on("drain",()=>this.resume()),this.results.on("resume",()=>this.resume())}matchEmit(t){this.results.write(t),this.results.flowing||this.pause()}stream(){const t=this.path;return t.isUnknown()?t.lstat().then(()=>{this.walkCB(t,this.patterns,()=>this.results.end())}):this.walkCB(t,this.patterns,()=>this.results.end()),this.results}streamSync(){return this.path.isUnknown()&&this.path.lstatSync(),this.walkCBSync(this.path,this.patterns,()=>this.results.end()),this.results}}