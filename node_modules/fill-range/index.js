/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */
"use strict";const util=require("util"),toRegexRange=require("to-regex-range"),isObject=e=>null!==e&&"object"==typeof e&&!Array.isArray(e),transform=e=>r=>!0===e?Number(r):String(r),isValidValue=e=>"number"==typeof e||"string"==typeof e&&""!==e,isNumber=e=>Number.isInteger(+e),zeros=e=>{let r=`${e}`,t=-1;if("-"===r[0]&&(r=r.slice(1)),"0"===r)return!1;for(;"0"===r[++t];);return t>0},stringify=(e,r,t)=>"string"==typeof e||"string"==typeof r||!0===t.stringify,pad=(e,r,t)=>{if(r>0){let t="-"===e[0]?"-":"";t&&(e=e.slice(1)),e=t+e.padStart(t?r-1:r,"0")}return!1===t?String(e):e},toMaxLen=(e,r)=>{let t="-"===e[0]?"-":"";for(t&&(e=e.slice(1),r--);e.length<r;)e="0"+e;return t?"-"+e:e},toSequence=(e,r,t)=>{e.negatives.sort((e,r)=>e<r?-1:e>r?1:0),e.positives.sort((e,r)=>e<r?-1:e>r?1:0);let i,n=r.capture?"":"?:",a="",s="";return e.positives.length&&(a=e.positives.map(e=>toMaxLen(String(e),t)).join("|")),e.negatives.length&&(s=`-(${n}${e.negatives.map(e=>toMaxLen(String(e),t)).join("|")})`),i=a&&s?`${a}|${s}`:a||s,r.wrap?`(${n}${i})`:i},toRange=(e,r,t,i)=>{if(t)return toRegexRange(e,r,{wrap:!1,...i});let n=String.fromCharCode(e);return e===r?n:`[${n}-${String.fromCharCode(r)}]`},toRegex=(e,r,t)=>{if(Array.isArray(e)){let r=!0===t.wrap,i=t.capture?"":"?:";return r?`(${i}${e.join("|")})`:e.join("|")}return toRegexRange(e,r,t)},rangeError=(...e)=>new RangeError("Invalid range arguments: "+util.inspect(...e)),invalidRange=(e,r,t)=>{if(!0===t.strictRanges)throw rangeError([e,r]);return[]},invalidStep=(e,r)=>{if(!0===r.strictRanges)throw new TypeError(`Expected step "${e}" to be a number`);return[]},fillNumbers=(e,r,t=1,i={})=>{let n=Number(e),a=Number(r);if(!Number.isInteger(n)||!Number.isInteger(a)){if(!0===i.strictRanges)throw rangeError([e,r]);return[]}0===n&&(n=0),0===a&&(a=0);let s=n>a,o=String(e),l=String(r),u=String(t);t=Math.max(Math.abs(t),1);let g=zeros(o)||zeros(l)||zeros(u),f=g?Math.max(o.length,l.length,u.length):0,p=!1===g&&!1===stringify(e,r,i),m=i.transform||transform(p);if(i.toRegex&&1===t)return toRange(toMaxLen(e,f),toMaxLen(r,f),!0,i);let h={negatives:[],positives:[]},b=e=>h[e<0?"negatives":"positives"].push(Math.abs(e)),R=[],x=0;for(;s?n>=a:n<=a;)!0===i.toRegex&&t>1?b(n):R.push(pad(m(n,x),f,p)),n=s?n-t:n+t,x++;return!0===i.toRegex?t>1?toSequence(h,i,f):toRegex(R,null,{wrap:!1,...i}):R},fillLetters=(e,r,t=1,i={})=>{if(!isNumber(e)&&e.length>1||!isNumber(r)&&r.length>1)return invalidRange(e,r,i);let n=i.transform||(e=>String.fromCharCode(e)),a=`${e}`.charCodeAt(0),s=`${r}`.charCodeAt(0),o=a>s,l=Math.min(a,s),u=Math.max(a,s);if(i.toRegex&&1===t)return toRange(l,u,!1,i);let g=[],f=0;for(;o?a>=s:a<=s;)g.push(n(a,f)),a=o?a-t:a+t,f++;return!0===i.toRegex?toRegex(g,null,{wrap:!1,options:i}):g},fill=(e,r,t,i={})=>{if(null==r&&isValidValue(e))return[e];if(!isValidValue(e)||!isValidValue(r))return invalidRange(e,r,i);if("function"==typeof t)return fill(e,r,1,{transform:t});if(isObject(t))return fill(e,r,0,t);let n={...i};return!0===n.capture&&(n.wrap=!0),t=t||n.step||1,isNumber(t)?isNumber(e)&&isNumber(r)?fillNumbers(e,r,t,n):fillLetters(e,r,Math.max(Math.abs(t),1),n):null==t||isObject(t)?fill(e,r,1,t):invalidStep(t,n)};module.exports=fill;