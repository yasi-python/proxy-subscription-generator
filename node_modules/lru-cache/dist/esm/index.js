const perf="object"==typeof performance&&performance&&"function"==typeof performance.now?performance:Date,warned=new Set,PROCESS="object"==typeof process&&process?process:{},emitWarning=(t,e,i,s)=>{"function"==typeof PROCESS.emitWarning?PROCESS.emitWarning(t,e,i,s):console.error(`[${i}] ${e}: ${t}`)};let AC=globalThis.AbortController,AS=globalThis.AbortSignal;if(void 0===AC){AS=class{onabort;_onabort=[];reason;aborted=!1;addEventListener(t,e){this._onabort.push(e)}},AC=class{constructor(){e()}signal=new AS;abort(t){if(!this.signal.aborted){this.signal.reason=t,this.signal.aborted=!0;for(const e of this.signal._onabort)e(t);this.signal.onabort?.(t)}}};let t="1"!==PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING;const e=()=>{t&&(t=!1,emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.","NO_ABORT_CONTROLLER","ENOTSUP",e))}}const shouldWarn=t=>!warned.has(t),TYPE=Symbol("type"),isPosInt=t=>t&&t===Math.floor(t)&&t>0&&isFinite(t),getUintArray=t=>isPosInt(t)?t<=Math.pow(2,8)?Uint8Array:t<=Math.pow(2,16)?Uint16Array:t<=Math.pow(2,32)?Uint32Array:t<=Number.MAX_SAFE_INTEGER?ZeroArray:null:null;class ZeroArray extends Array{constructor(t){super(t),this.fill(0)}}class Stack{heap;length;static#t=!1;static create(t){const e=getUintArray(t);if(!e)return[];Stack.#t=!0;const i=new Stack(t,e);return Stack.#t=!1,i}constructor(t,e){if(!Stack.#t)throw new TypeError("instantiate Stack using Stack.create(n)");this.heap=new e(t),this.length=0}push(t){this.heap[this.length++]=t}pop(){return this.heap[--this.length]}}export class LRUCache{#e;#i;#s;#h;#o;#n;ttl;ttlResolution;ttlAutopurge;updateAgeOnGet;updateAgeOnHas;allowStale;noDisposeOnSet;noUpdateTTL;maxEntrySize;sizeCalculation;noDeleteOnFetchRejection;noDeleteOnStaleGet;allowStaleOnFetchAbort;allowStaleOnFetchRejection;ignoreFetchAbort;#r;#a;#l;#c;#d;#u;#f;#g;#p;#S;#w;#_;#v;#y;#m;#A;#F;static unsafeExposeInternals(t){return{starts:t.#v,ttls:t.#y,sizes:t.#_,keyMap:t.#l,keyList:t.#c,valList:t.#d,next:t.#u,prev:t.#f,get head(){return t.#g},get tail(){return t.#p},free:t.#S,isBackgroundFetch:e=>t.#b(e),backgroundFetch:(e,i,s,h)=>t.#O(e,i,s,h),moveToTail:e=>t.#E(e),indexes:e=>t.#z(e),rindexes:e=>t.#T(e),isStale:e=>t.#C(e)}}get max(){return this.#e}get maxSize(){return this.#i}get calculatedSize(){return this.#a}get size(){return this.#r}get fetchMethod(){return this.#o}get memoMethod(){return this.#n}get dispose(){return this.#s}get disposeAfter(){return this.#h}constructor(t){const{max:e=0,ttl:i,ttlResolution:s=1,ttlAutopurge:h,updateAgeOnGet:o,updateAgeOnHas:n,allowStale:r,dispose:a,disposeAfter:l,noDisposeOnSet:c,noUpdateTTL:d,maxSize:u=0,maxEntrySize:f=0,sizeCalculation:g,fetchMethod:p,memoMethod:S,noDeleteOnFetchRejection:w,noDeleteOnStaleGet:_,allowStaleOnFetchRejection:v,allowStaleOnFetchAbort:y,ignoreFetchAbort:m}=t;if(0!==e&&!isPosInt(e))throw new TypeError("max option must be a nonnegative integer");const A=e?getUintArray(e):Array;if(!A)throw new Error("invalid max value: "+e);if(this.#e=e,this.#i=u,this.maxEntrySize=f||this.#i,this.sizeCalculation=g,this.sizeCalculation){if(!this.#i&&!this.maxEntrySize)throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");if("function"!=typeof this.sizeCalculation)throw new TypeError("sizeCalculation set to non-function")}if(void 0!==S&&"function"!=typeof S)throw new TypeError("memoMethod must be a function if defined");if(this.#n=S,void 0!==p&&"function"!=typeof p)throw new TypeError("fetchMethod must be a function if specified");if(this.#o=p,this.#A=!!p,this.#l=new Map,this.#c=new Array(e).fill(void 0),this.#d=new Array(e).fill(void 0),this.#u=new A(e),this.#f=new A(e),this.#g=0,this.#p=0,this.#S=Stack.create(e),this.#r=0,this.#a=0,"function"==typeof a&&(this.#s=a),"function"==typeof l?(this.#h=l,this.#w=[]):(this.#h=void 0,this.#w=void 0),this.#m=!!this.#s,this.#F=!!this.#h,this.noDisposeOnSet=!!c,this.noUpdateTTL=!!d,this.noDeleteOnFetchRejection=!!w,this.allowStaleOnFetchRejection=!!v,this.allowStaleOnFetchAbort=!!y,this.ignoreFetchAbort=!!m,0!==this.maxEntrySize){if(0!==this.#i&&!isPosInt(this.#i))throw new TypeError("maxSize must be a positive integer if specified");if(!isPosInt(this.maxEntrySize))throw new TypeError("maxEntrySize must be a positive integer if specified");this.#R()}if(this.allowStale=!!r,this.noDeleteOnStaleGet=!!_,this.updateAgeOnGet=!!o,this.updateAgeOnHas=!!n,this.ttlResolution=isPosInt(s)||0===s?s:1,this.ttlAutopurge=!!h,this.ttl=i||0,this.ttl){if(!isPosInt(this.ttl))throw new TypeError("ttl must be a positive integer if specified");this.#x()}if(0===this.#e&&0===this.ttl&&0===this.#i)throw new TypeError("At least one of max, maxSize, or ttl is required");if(!this.ttlAutopurge&&!this.#e&&!this.#i){const t="LRU_CACHE_UNBOUNDED";shouldWarn(t)&&(warned.add(t),emitWarning("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.","UnboundedCacheWarning",t,LRUCache))}}getRemainingTTL(t){return this.#l.has(t)?1/0:0}#x(){const t=new ZeroArray(this.#e),e=new ZeroArray(this.#e);this.#y=t,this.#v=e,this.#W=(i,s,h=perf.now())=>{if(e[i]=0!==s?h:0,t[i]=s,0!==s&&this.ttlAutopurge){const t=setTimeout(()=>{this.#C(i)&&this.#D(this.#c[i],"expire")},s+1);t.unref&&t.unref()}},this.#U=i=>{e[i]=0!==t[i]?perf.now():0},this.#L=(h,o)=>{if(t[o]){const n=t[o],r=e[o];if(!n||!r)return;h.ttl=n,h.start=r,h.now=i||s();const a=h.now-r;h.remainingTTL=n-a}};let i=0;const s=()=>{const t=perf.now();if(this.ttlResolution>0){i=t;const e=setTimeout(()=>i=0,this.ttlResolution);e.unref&&e.unref()}return t};this.getRemainingTTL=h=>{const o=this.#l.get(h);if(void 0===o)return 0;const n=t[o],r=e[o];return n&&r?n-((i||s())-r):1/0},this.#C=h=>{const o=e[h],n=t[h];return!!n&&!!o&&(i||s())-o>n}}#U=()=>{};#L=()=>{};#W=()=>{};#C=()=>!1;#R(){const t=new ZeroArray(this.#e);this.#a=0,this.#_=t,this.#G=e=>{this.#a-=t[e],t[e]=0},this.#P=(t,e,i,s)=>{if(this.#b(e))return 0;if(!isPosInt(i)){if(!s)throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");if("function"!=typeof s)throw new TypeError("sizeCalculation must be a function");if(i=s(e,t),!isPosInt(i))throw new TypeError("sizeCalculation return invalid (expect positive integer)")}return i},this.#j=(e,i,s)=>{if(t[e]=i,this.#i){const i=this.#i-t[e];for(;this.#a>i;)this.#I(!0)}this.#a+=t[e],s&&(s.entrySize=i,s.totalCalculatedSize=this.#a)}}#G=t=>{};#j=(t,e,i)=>{};#P=(t,e,i,s)=>{if(i||s)throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");return 0};*#z({allowStale:t=this.allowStale}={}){if(this.#r)for(let e=this.#p;this.#k(e)&&(!t&&this.#C(e)||(yield e),e!==this.#g);)e=this.#f[e]}*#T({allowStale:t=this.allowStale}={}){if(this.#r)for(let e=this.#g;this.#k(e)&&(!t&&this.#C(e)||(yield e),e!==this.#p);)e=this.#u[e]}#k(t){return void 0!==t&&this.#l.get(this.#c[t])===t}*entries(){for(const t of this.#z())void 0===this.#d[t]||void 0===this.#c[t]||this.#b(this.#d[t])||(yield[this.#c[t],this.#d[t]])}*rentries(){for(const t of this.#T())void 0===this.#d[t]||void 0===this.#c[t]||this.#b(this.#d[t])||(yield[this.#c[t],this.#d[t]])}*keys(){for(const t of this.#z()){const e=this.#c[t];void 0===e||this.#b(this.#d[t])||(yield e)}}*rkeys(){for(const t of this.#T()){const e=this.#c[t];void 0===e||this.#b(this.#d[t])||(yield e)}}*values(){for(const t of this.#z())void 0===this.#d[t]||this.#b(this.#d[t])||(yield this.#d[t])}*rvalues(){for(const t of this.#T())void 0===this.#d[t]||this.#b(this.#d[t])||(yield this.#d[t])}[Symbol.iterator](){return this.entries()}[Symbol.toStringTag]="LRUCache";find(t,e={}){for(const i of this.#z()){const s=this.#d[i],h=this.#b(s)?s.__staleWhileFetching:s;if(void 0!==h&&t(h,this.#c[i],this))return this.get(this.#c[i],e)}}forEach(t,e=this){for(const i of this.#z()){const s=this.#d[i],h=this.#b(s)?s.__staleWhileFetching:s;void 0!==h&&t.call(e,h,this.#c[i],this)}}rforEach(t,e=this){for(const i of this.#T()){const s=this.#d[i],h=this.#b(s)?s.__staleWhileFetching:s;void 0!==h&&t.call(e,h,this.#c[i],this)}}purgeStale(){let t=!1;for(const e of this.#T({allowStale:!0}))this.#C(e)&&(this.#D(this.#c[e],"expire"),t=!0);return t}info(t){const e=this.#l.get(t);if(void 0===e)return;const i=this.#d[e],s=this.#b(i)?i.__staleWhileFetching:i;if(void 0===s)return;const h={value:s};if(this.#y&&this.#v){const t=this.#y[e],i=this.#v[e];if(t&&i){const e=t-(perf.now()-i);h.ttl=e,h.start=Date.now()}}return this.#_&&(h.size=this.#_[e]),h}dump(){const t=[];for(const e of this.#z({allowStale:!0})){const i=this.#c[e],s=this.#d[e],h=this.#b(s)?s.__staleWhileFetching:s;if(void 0===h||void 0===i)continue;const o={value:h};if(this.#y&&this.#v){o.ttl=this.#y[e];const t=perf.now()-this.#v[e];o.start=Math.floor(Date.now()-t)}this.#_&&(o.size=this.#_[e]),t.unshift([i,o])}return t}load(t){this.clear();for(const[e,i]of t){if(i.start){const t=Date.now()-i.start;i.start=perf.now()-t}this.set(e,i.value,i)}}set(t,e,i={}){if(void 0===e)return this.delete(t),this;const{ttl:s=this.ttl,start:h,noDisposeOnSet:o=this.noDisposeOnSet,sizeCalculation:n=this.sizeCalculation,status:r}=i;let{noUpdateTTL:a=this.noUpdateTTL}=i;const l=this.#P(t,e,i.size||0,n);if(this.maxEntrySize&&l>this.maxEntrySize)return r&&(r.set="miss",r.maxEntrySizeExceeded=!0),this.#D(t,"set"),this;let c=0===this.#r?void 0:this.#l.get(t);if(void 0===c)c=0===this.#r?this.#p:0!==this.#S.length?this.#S.pop():this.#r===this.#e?this.#I(!1):this.#r,this.#c[c]=t,this.#d[c]=e,this.#l.set(t,c),this.#u[this.#p]=c,this.#f[c]=this.#p,this.#p=c,this.#r++,this.#j(c,l,r),r&&(r.set="add"),a=!1;else{this.#E(c);const i=this.#d[c];if(e!==i){if(this.#A&&this.#b(i)){i.__abortController.abort(new Error("replaced"));const{__staleWhileFetching:e}=i;void 0===e||o||(this.#m&&this.#s?.(e,t,"set"),this.#F&&this.#w?.push([e,t,"set"]))}else o||(this.#m&&this.#s?.(i,t,"set"),this.#F&&this.#w?.push([i,t,"set"]));if(this.#G(c),this.#j(c,l,r),this.#d[c]=e,r){r.set="replace";const t=i&&this.#b(i)?i.__staleWhileFetching:i;void 0!==t&&(r.oldValue=t)}}else r&&(r.set="update")}if(0===s||this.#y||this.#x(),this.#y&&(a||this.#W(c,s,h),r&&this.#L(r,c)),!o&&this.#F&&this.#w){const t=this.#w;let e;for(;e=t?.shift();)this.#h?.(...e)}return this}pop(){try{for(;this.#r;){const t=this.#d[this.#g];if(this.#I(!0),this.#b(t)){if(t.__staleWhileFetching)return t.__staleWhileFetching}else if(void 0!==t)return t}}finally{if(this.#F&&this.#w){const t=this.#w;let e;for(;e=t?.shift();)this.#h?.(...e)}}}#I(t){const e=this.#g,i=this.#c[e],s=this.#d[e];return this.#A&&this.#b(s)?s.__abortController.abort(new Error("evicted")):(this.#m||this.#F)&&(this.#m&&this.#s?.(s,i,"evict"),this.#F&&this.#w?.push([s,i,"evict"])),this.#G(e),t&&(this.#c[e]=void 0,this.#d[e]=void 0,this.#S.push(e)),1===this.#r?(this.#g=this.#p=0,this.#S.length=0):this.#g=this.#u[e],this.#l.delete(i),this.#r--,e}has(t,e={}){const{updateAgeOnHas:i=this.updateAgeOnHas,status:s}=e,h=this.#l.get(t);if(void 0!==h){const t=this.#d[h];if(this.#b(t)&&void 0===t.__staleWhileFetching)return!1;if(!this.#C(h))return i&&this.#U(h),s&&(s.has="hit",this.#L(s,h)),!0;s&&(s.has="stale",this.#L(s,h))}else s&&(s.has="miss");return!1}peek(t,e={}){const{allowStale:i=this.allowStale}=e,s=this.#l.get(t);if(void 0===s||!i&&this.#C(s))return;const h=this.#d[s];return this.#b(h)?h.__staleWhileFetching:h}#O(t,e,i,s){const h=void 0===e?void 0:this.#d[e];if(this.#b(h))return h;const o=new AC,{signal:n}=i;n?.addEventListener("abort",()=>o.abort(n.reason),{signal:o.signal});const r={signal:o.signal,options:i,context:s},a=(s,h=!1)=>{const{aborted:n}=o.signal,a=i.ignoreFetchAbort&&void 0!==s;if(i.status&&(n&&!h?(i.status.fetchAborted=!0,i.status.fetchError=o.signal.reason,a&&(i.status.fetchAbortIgnored=!0)):i.status.fetchResolved=!0),n&&!a&&!h)return l(o.signal.reason);const d=c;return this.#d[e]===c&&(void 0===s?d.__staleWhileFetching?this.#d[e]=d.__staleWhileFetching:this.#D(t,"fetch"):(i.status&&(i.status.fetchUpdated=!0),this.set(t,s,r.options))),s},l=s=>{const{aborted:h}=o.signal,n=h&&i.allowStaleOnFetchAbort,r=n||i.allowStaleOnFetchRejection,a=r||i.noDeleteOnFetchRejection,l=c;if(this.#d[e]===c&&(a&&void 0!==l.__staleWhileFetching?n||(this.#d[e]=l.__staleWhileFetching):this.#D(t,"fetch")),r)return i.status&&void 0!==l.__staleWhileFetching&&(i.status.returnedStale=!0),l.__staleWhileFetching;if(l.__returned===l)throw s};i.status&&(i.status.fetchDispatched=!0);const c=new Promise((e,s)=>{const n=this.#o?.(t,h,r);n&&n instanceof Promise&&n.then(t=>e(void 0===t?void 0:t),s),o.signal.addEventListener("abort",()=>{i.ignoreFetchAbort&&!i.allowStaleOnFetchAbort||(e(void 0),i.allowStaleOnFetchAbort&&(e=t=>a(t,!0)))})}).then(a,t=>(i.status&&(i.status.fetchRejected=!0,i.status.fetchError=t),l(t))),d=Object.assign(c,{__abortController:o,__staleWhileFetching:h,__returned:void 0});return void 0===e?(this.set(t,d,{...r.options,status:void 0}),e=this.#l.get(t)):this.#d[e]=d,d}#b(t){if(!this.#A)return!1;const e=t;return!!e&&e instanceof Promise&&e.hasOwnProperty("__staleWhileFetching")&&e.__abortController instanceof AC}async fetch(t,e={}){const{allowStale:i=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet,noDeleteOnStaleGet:h=this.noDeleteOnStaleGet,ttl:o=this.ttl,noDisposeOnSet:n=this.noDisposeOnSet,size:r=0,sizeCalculation:a=this.sizeCalculation,noUpdateTTL:l=this.noUpdateTTL,noDeleteOnFetchRejection:c=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:d=this.allowStaleOnFetchRejection,ignoreFetchAbort:u=this.ignoreFetchAbort,allowStaleOnFetchAbort:f=this.allowStaleOnFetchAbort,context:g,forceRefresh:p=!1,status:S,signal:w}=e;if(!this.#A)return S&&(S.fetch="get"),this.get(t,{allowStale:i,updateAgeOnGet:s,noDeleteOnStaleGet:h,status:S});const _={allowStale:i,updateAgeOnGet:s,noDeleteOnStaleGet:h,ttl:o,noDisposeOnSet:n,size:r,sizeCalculation:a,noUpdateTTL:l,noDeleteOnFetchRejection:c,allowStaleOnFetchRejection:d,allowStaleOnFetchAbort:f,ignoreFetchAbort:u,status:S,signal:w};let v=this.#l.get(t);if(void 0===v){S&&(S.fetch="miss");const e=this.#O(t,v,_,g);return e.__returned=e}{const e=this.#d[v];if(this.#b(e)){const t=i&&void 0!==e.__staleWhileFetching;return S&&(S.fetch="inflight",t&&(S.returnedStale=!0)),t?e.__staleWhileFetching:e.__returned=e}const h=this.#C(v);if(!p&&!h)return S&&(S.fetch="hit"),this.#E(v),s&&this.#U(v),S&&this.#L(S,v),e;const o=this.#O(t,v,_,g),n=void 0!==o.__staleWhileFetching&&i;return S&&(S.fetch=h?"stale":"refresh",n&&h&&(S.returnedStale=!0)),n?o.__staleWhileFetching:o.__returned=o}}async forceFetch(t,e={}){const i=await this.fetch(t,e);if(void 0===i)throw new Error("fetch() returned undefined");return i}memo(t,e={}){const i=this.#n;if(!i)throw new Error("no memoMethod provided to constructor");const{context:s,forceRefresh:h,...o}=e,n=this.get(t,o);if(!h&&void 0!==n)return n;const r=i(t,n,{options:o,context:s});return this.set(t,r,o),r}get(t,e={}){const{allowStale:i=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet,noDeleteOnStaleGet:h=this.noDeleteOnStaleGet,status:o}=e,n=this.#l.get(t);if(void 0!==n){const e=this.#d[n],r=this.#b(e);return o&&this.#L(o,n),this.#C(n)?(o&&(o.get="stale"),r?(o&&i&&void 0!==e.__staleWhileFetching&&(o.returnedStale=!0),i?e.__staleWhileFetching:void 0):(h||this.#D(t,"expire"),o&&i&&(o.returnedStale=!0),i?e:void 0)):(o&&(o.get="hit"),r?e.__staleWhileFetching:(this.#E(n),s&&this.#U(n),e))}o&&(o.get="miss")}#M(t,e){this.#f[e]=t,this.#u[t]=e}#E(t){t!==this.#p&&(t===this.#g?this.#g=this.#u[t]:this.#M(this.#f[t],this.#u[t]),this.#M(this.#p,t),this.#p=t)}delete(t){return this.#D(t,"delete")}#D(t,e){let i=!1;if(0!==this.#r){const s=this.#l.get(t);if(void 0!==s)if(i=!0,1===this.#r)this.#N(e);else{this.#G(s);const i=this.#d[s];if(this.#b(i)?i.__abortController.abort(new Error("deleted")):(this.#m||this.#F)&&(this.#m&&this.#s?.(i,t,e),this.#F&&this.#w?.push([i,t,e])),this.#l.delete(t),this.#c[s]=void 0,this.#d[s]=void 0,s===this.#p)this.#p=this.#f[s];else if(s===this.#g)this.#g=this.#u[s];else{const t=this.#f[s];this.#u[t]=this.#u[s];const e=this.#u[s];this.#f[e]=this.#f[s]}this.#r--,this.#S.push(s)}}if(this.#F&&this.#w?.length){const t=this.#w;let e;for(;e=t?.shift();)this.#h?.(...e)}return i}clear(){return this.#N("delete")}#N(t){for(const e of this.#T({allowStale:!0})){const i=this.#d[e];if(this.#b(i))i.__abortController.abort(new Error("deleted"));else{const s=this.#c[e];this.#m&&this.#s?.(i,s,t),this.#F&&this.#w?.push([i,s,t])}}if(this.#l.clear(),this.#d.fill(void 0),this.#c.fill(void 0),this.#y&&this.#v&&(this.#y.fill(0),this.#v.fill(0)),this.#_&&this.#_.fill(0),this.#g=0,this.#p=0,this.#S.length=0,this.#a=0,this.#r=0,this.#F&&this.#w){const t=this.#w;let e;for(;e=t?.shift();)this.#h?.(...e)}}}