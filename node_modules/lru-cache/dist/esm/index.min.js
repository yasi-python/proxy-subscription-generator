var G=(t,e,i)=>{if(!e.has(t))throw TypeError("Cannot "+i)},I=(t,e,i)=>(G(t,e,"read from private field"),i?i.call(t):e.get(t)),j=(t,e,i)=>{if(e.has(t))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(t):e.set(t,i)},x=(t,e,i,s)=>(G(t,e,"write to private field"),s?s.call(t,i):e.set(t,i),i),T="object"==typeof performance&&performance&&"function"==typeof performance.now?performance:Date,P=new Set,M="object"==typeof process&&process?process:{},H=(t,e,i,s)=>{"function"==typeof M.emitWarning?M.emitWarning(t,e,i,s):console.error(`[${i}] ${e}: ${t}`)},W=globalThis.AbortController,N=globalThis.AbortSignal;if(typeof W>"u"){N=class{onabort;_onabort=[];reason;aborted=!1;addEventListener(t,e){this._onabort.push(e)}},W=class{constructor(){e()}signal=new N;abort(t){if(!this.signal.aborted){this.signal.reason=t,this.signal.aborted=!0;for(let e of this.signal._onabort)e(t);this.signal.onabort?.(t)}}};let t="1"!==M.env?.LRU_CACHE_IGNORE_AC_WARNING,e=()=>{t&&(t=!1,H("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.","NO_ABORT_CONTROLLER","ENOTSUP",e))}}var z,V=t=>!P.has(t),Y=Symbol("type"),A=t=>t&&t===Math.floor(t)&&t>0&&isFinite(t),k=t=>A(t)?t<=Math.pow(2,8)?Uint8Array:t<=Math.pow(2,16)?Uint16Array:t<=Math.pow(2,32)?Uint32Array:t<=Number.MAX_SAFE_INTEGER?O:null:null,O=class extends Array{constructor(t){super(t),this.fill(0)}},E=class{heap;length;static create(t){let e=k(t);if(!e)return[];x(E,z,!0);let i=new E(t,e);return x(E,z,!1),i}constructor(t,e){if(!I(E,z))throw new TypeError("instantiate Stack using Stack.create(n)");this.heap=new e(t),this.length=0}push(t){this.heap[this.length++]=t}pop(){return this.heap[--this.length]}},R=E;z=new WeakMap,j(R,z,!1);var D=class{#t;#e;#i;#s;#h;#o;ttl;ttlResolution;ttlAutopurge;updateAgeOnGet;updateAgeOnHas;allowStale;noDisposeOnSet;noUpdateTTL;maxEntrySize;sizeCalculation;noDeleteOnFetchRejection;noDeleteOnStaleGet;allowStaleOnFetchAbort;allowStaleOnFetchRejection;ignoreFetchAbort;#r;#n;#l;#a;#f;#u;#c;#d;#g;#p;#w;#v;#S;#_;#y;#m;#A;static unsafeExposeInternals(t){return{starts:t.#S,ttls:t.#_,sizes:t.#v,keyMap:t.#l,keyList:t.#a,valList:t.#f,next:t.#u,prev:t.#c,get head(){return t.#d},get tail(){return t.#g},free:t.#p,isBackgroundFetch:e=>t.#b(e),backgroundFetch:(e,i,s,h)=>t.#O(e,i,s,h),moveToTail:e=>t.#E(e),indexes:e=>t.#F(e),rindexes:e=>t.#z(e),isStale:e=>t.#T(e)}}get max(){return this.#t}get maxSize(){return this.#e}get calculatedSize(){return this.#n}get size(){return this.#r}get fetchMethod(){return this.#h}get memoMethod(){return this.#o}get dispose(){return this.#i}get disposeAfter(){return this.#s}constructor(t){let{max:e=0,ttl:i,ttlResolution:s=1,ttlAutopurge:h,updateAgeOnGet:o,updateAgeOnHas:r,allowStale:n,dispose:l,disposeAfter:a,noDisposeOnSet:f,noUpdateTTL:u,maxSize:c=0,maxEntrySize:d=0,sizeCalculation:g,fetchMethod:p,memoMethod:w,noDeleteOnFetchRejection:v,noDeleteOnStaleGet:S,allowStaleOnFetchRejection:_,allowStaleOnFetchAbort:y,ignoreFetchAbort:m}=t;if(0!==e&&!A(e))throw new TypeError("max option must be a nonnegative integer");let b=e?k(e):Array;if(!b)throw new Error("invalid max value: "+e);if(this.#t=e,this.#e=c,this.maxEntrySize=d||this.#e,this.sizeCalculation=g,this.sizeCalculation){if(!this.#e&&!this.maxEntrySize)throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");if("function"!=typeof this.sizeCalculation)throw new TypeError("sizeCalculation set to non-function")}if(void 0!==w&&"function"!=typeof w)throw new TypeError("memoMethod must be a function if defined");if(this.#o=w,void 0!==p&&"function"!=typeof p)throw new TypeError("fetchMethod must be a function if specified");if(this.#h=p,this.#m=!!p,this.#l=new Map,this.#a=new Array(e).fill(void 0),this.#f=new Array(e).fill(void 0),this.#u=new b(e),this.#c=new b(e),this.#d=0,this.#g=0,this.#p=R.create(e),this.#r=0,this.#n=0,"function"==typeof l&&(this.#i=l),"function"==typeof a?(this.#s=a,this.#w=[]):(this.#s=void 0,this.#w=void 0),this.#y=!!this.#i,this.#A=!!this.#s,this.noDisposeOnSet=!!f,this.noUpdateTTL=!!u,this.noDeleteOnFetchRejection=!!v,this.allowStaleOnFetchRejection=!!_,this.allowStaleOnFetchAbort=!!y,this.ignoreFetchAbort=!!m,0!==this.maxEntrySize){if(0!==this.#e&&!A(this.#e))throw new TypeError("maxSize must be a positive integer if specified");if(!A(this.maxEntrySize))throw new TypeError("maxEntrySize must be a positive integer if specified");this.#x()}if(this.allowStale=!!n,this.noDeleteOnStaleGet=!!S,this.updateAgeOnGet=!!o,this.updateAgeOnHas=!!r,this.ttlResolution=A(s)||0===s?s:1,this.ttlAutopurge=!!h,this.ttl=i||0,this.ttl){if(!A(this.ttl))throw new TypeError("ttl must be a positive integer if specified");this.#W()}if(0===this.#t&&0===this.ttl&&0===this.#e)throw new TypeError("At least one of max, maxSize, or ttl is required");if(!this.ttlAutopurge&&!this.#t&&!this.#e){let t="LRU_CACHE_UNBOUNDED";V(t)&&(P.add(t),H("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.","UnboundedCacheWarning",t,D))}}getRemainingTTL(t){return this.#l.has(t)?1/0:0}#W(){let t=new O(this.#t),e=new O(this.#t);this.#_=t,this.#S=e,this.#R=(i,s,h=T.now())=>{if(e[i]=0!==s?h:0,t[i]=s,0!==s&&this.ttlAutopurge){let t=setTimeout(()=>{this.#T(i)&&this.#C(this.#a[i],"expire")},s+1);t.unref&&t.unref()}},this.#D=i=>{e[i]=0!==t[i]?T.now():0},this.#G=(h,o)=>{if(t[o]){let r=t[o],n=e[o];if(!r||!n)return;h.ttl=r,h.start=n,h.now=i||s();let l=h.now-n;h.remainingTTL=r-l}};let i=0,s=()=>{let t=T.now();if(this.ttlResolution>0){i=t;let e=setTimeout(()=>i=0,this.ttlResolution);e.unref&&e.unref()}return t};this.getRemainingTTL=h=>{let o=this.#l.get(h);if(void 0===o)return 0;let r=t[o],n=e[o];return r&&n?r-((i||s())-n):1/0},this.#T=h=>{let o=e[h],r=t[h];return!!r&&!!o&&(i||s())-o>r}}#D=()=>{};#G=()=>{};#R=()=>{};#T=()=>!1;#x(){let t=new O(this.#t);this.#n=0,this.#v=t,this.#L=e=>{this.#n-=t[e],t[e]=0},this.#U=(t,e,i,s)=>{if(this.#b(e))return 0;if(!A(i)){if(!s)throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");if("function"!=typeof s)throw new TypeError("sizeCalculation must be a function");if(i=s(e,t),!A(i))throw new TypeError("sizeCalculation return invalid (expect positive integer)")}return i},this.#j=(e,i,s)=>{if(t[e]=i,this.#e){let i=this.#e-t[e];for(;this.#n>i;)this.#M(!0)}this.#n+=t[e],s&&(s.entrySize=i,s.totalCalculatedSize=this.#n)}}#L=t=>{};#j=(t,e,i)=>{};#U=(t,e,i,s)=>{if(i||s)throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");return 0};*#F({allowStale:t=this.allowStale}={}){if(this.#r)for(let e=this.#g;this.#N(e)&&((t||!this.#T(e))&&(yield e),e!==this.#d);)e=this.#c[e]}*#z({allowStale:t=this.allowStale}={}){if(this.#r)for(let e=this.#d;this.#N(e)&&((t||!this.#T(e))&&(yield e),e!==this.#g);)e=this.#u[e]}#N(t){return void 0!==t&&this.#l.get(this.#a[t])===t}*entries(){for(let t of this.#F())void 0!==this.#f[t]&&void 0!==this.#a[t]&&!this.#b(this.#f[t])&&(yield[this.#a[t],this.#f[t]])}*rentries(){for(let t of this.#z())void 0!==this.#f[t]&&void 0!==this.#a[t]&&!this.#b(this.#f[t])&&(yield[this.#a[t],this.#f[t]])}*keys(){for(let t of this.#F()){let e=this.#a[t];void 0!==e&&!this.#b(this.#f[t])&&(yield e)}}*rkeys(){for(let t of this.#z()){let e=this.#a[t];void 0!==e&&!this.#b(this.#f[t])&&(yield e)}}*values(){for(let t of this.#F())void 0!==this.#f[t]&&!this.#b(this.#f[t])&&(yield this.#f[t])}*rvalues(){for(let t of this.#z())void 0!==this.#f[t]&&!this.#b(this.#f[t])&&(yield this.#f[t])}[Symbol.iterator](){return this.entries()}[Symbol.toStringTag]="LRUCache";find(t,e={}){for(let i of this.#F()){let s=this.#f[i],h=this.#b(s)?s.__staleWhileFetching:s;if(void 0!==h&&t(h,this.#a[i],this))return this.get(this.#a[i],e)}}forEach(t,e=this){for(let i of this.#F()){let s=this.#f[i],h=this.#b(s)?s.__staleWhileFetching:s;void 0!==h&&t.call(e,h,this.#a[i],this)}}rforEach(t,e=this){for(let i of this.#z()){let s=this.#f[i],h=this.#b(s)?s.__staleWhileFetching:s;void 0!==h&&t.call(e,h,this.#a[i],this)}}purgeStale(){let t=!1;for(let e of this.#z({allowStale:!0}))this.#T(e)&&(this.#C(this.#a[e],"expire"),t=!0);return t}info(t){let e=this.#l.get(t);if(void 0===e)return;let i=this.#f[e],s=this.#b(i)?i.__staleWhileFetching:i;if(void 0===s)return;let h={value:s};if(this.#_&&this.#S){let t=this.#_[e],i=this.#S[e];if(t&&i){let e=t-(T.now()-i);h.ttl=e,h.start=Date.now()}}return this.#v&&(h.size=this.#v[e]),h}dump(){let t=[];for(let e of this.#F({allowStale:!0})){let i=this.#a[e],s=this.#f[e],h=this.#b(s)?s.__staleWhileFetching:s;if(void 0===h||void 0===i)continue;let o={value:h};if(this.#_&&this.#S){o.ttl=this.#_[e];let t=T.now()-this.#S[e];o.start=Math.floor(Date.now()-t)}this.#v&&(o.size=this.#v[e]),t.unshift([i,o])}return t}load(t){this.clear();for(let[e,i]of t){if(i.start){let t=Date.now()-i.start;i.start=T.now()-t}this.set(e,i.value,i)}}set(t,e,i={}){if(void 0===e)return this.delete(t),this;let{ttl:s=this.ttl,start:h,noDisposeOnSet:o=this.noDisposeOnSet,sizeCalculation:r=this.sizeCalculation,status:n}=i,{noUpdateTTL:l=this.noUpdateTTL}=i,a=this.#U(t,e,i.size||0,r);if(this.maxEntrySize&&a>this.maxEntrySize)return n&&(n.set="miss",n.maxEntrySizeExceeded=!0),this.#C(t,"set"),this;let f=0===this.#r?void 0:this.#l.get(t);if(void 0===f)f=0===this.#r?this.#g:0!==this.#p.length?this.#p.pop():this.#r===this.#t?this.#M(!1):this.#r,this.#a[f]=t,this.#f[f]=e,this.#l.set(t,f),this.#u[this.#g]=f,this.#c[f]=this.#g,this.#g=f,this.#r++,this.#j(f,a,n),n&&(n.set="add"),l=!1;else{this.#E(f);let i=this.#f[f];if(e!==i){if(this.#m&&this.#b(i)){i.__abortController.abort(new Error("replaced"));let{__staleWhileFetching:e}=i;void 0!==e&&!o&&(this.#y&&this.#i?.(e,t,"set"),this.#A&&this.#w?.push([e,t,"set"]))}else o||(this.#y&&this.#i?.(i,t,"set"),this.#A&&this.#w?.push([i,t,"set"]));if(this.#L(f),this.#j(f,a,n),this.#f[f]=e,n){n.set="replace";let t=i&&this.#b(i)?i.__staleWhileFetching:i;void 0!==t&&(n.oldValue=t)}}else n&&(n.set="update")}if(0!==s&&!this.#_&&this.#W(),this.#_&&(l||this.#R(f,s,h),n&&this.#G(n,f)),!o&&this.#A&&this.#w){let t,e=this.#w;for(;t=e?.shift();)this.#s?.(...t)}return this}pop(){try{for(;this.#r;){let t=this.#f[this.#d];if(this.#M(!0),this.#b(t)){if(t.__staleWhileFetching)return t.__staleWhileFetching}else if(void 0!==t)return t}}finally{if(this.#A&&this.#w){let t,e=this.#w;for(;t=e?.shift();)this.#s?.(...t)}}}#M(t){let e=this.#d,i=this.#a[e],s=this.#f[e];return this.#m&&this.#b(s)?s.__abortController.abort(new Error("evicted")):(this.#y||this.#A)&&(this.#y&&this.#i?.(s,i,"evict"),this.#A&&this.#w?.push([s,i,"evict"])),this.#L(e),t&&(this.#a[e]=void 0,this.#f[e]=void 0,this.#p.push(e)),1===this.#r?(this.#d=this.#g=0,this.#p.length=0):this.#d=this.#u[e],this.#l.delete(i),this.#r--,e}has(t,e={}){let{updateAgeOnHas:i=this.updateAgeOnHas,status:s}=e,h=this.#l.get(t);if(void 0!==h){let t=this.#f[h];if(this.#b(t)&&void 0===t.__staleWhileFetching)return!1;if(!this.#T(h))return i&&this.#D(h),s&&(s.has="hit",this.#G(s,h)),!0;s&&(s.has="stale",this.#G(s,h))}else s&&(s.has="miss");return!1}peek(t,e={}){let{allowStale:i=this.allowStale}=e,s=this.#l.get(t);if(void 0===s||!i&&this.#T(s))return;let h=this.#f[s];return this.#b(h)?h.__staleWhileFetching:h}#O(t,e,i,s){let h=void 0===e?void 0:this.#f[e];if(this.#b(h))return h;let o=new W,{signal:r}=i;r?.addEventListener("abort",()=>o.abort(r.reason),{signal:o.signal});let n={signal:o.signal,options:i,context:s},l=(s,h=!1)=>{let{aborted:r}=o.signal,l=i.ignoreFetchAbort&&void 0!==s;if(i.status&&(r&&!h?(i.status.fetchAborted=!0,i.status.fetchError=o.signal.reason,l&&(i.status.fetchAbortIgnored=!0)):i.status.fetchResolved=!0),r&&!l&&!h)return a(o.signal.reason);let u=f;return this.#f[e]===f&&(void 0===s?u.__staleWhileFetching?this.#f[e]=u.__staleWhileFetching:this.#C(t,"fetch"):(i.status&&(i.status.fetchUpdated=!0),this.set(t,s,n.options))),s},a=s=>{let{aborted:h}=o.signal,r=h&&i.allowStaleOnFetchAbort,n=r||i.allowStaleOnFetchRejection,l=n||i.noDeleteOnFetchRejection,a=f;if(this.#f[e]===f&&(l&&void 0!==a.__staleWhileFetching?r||(this.#f[e]=a.__staleWhileFetching):this.#C(t,"fetch")),n)return i.status&&void 0!==a.__staleWhileFetching&&(i.status.returnedStale=!0),a.__staleWhileFetching;if(a.__returned===a)throw s};i.status&&(i.status.fetchDispatched=!0);let f=new Promise((e,s)=>{let r=this.#h?.(t,h,n);r&&r instanceof Promise&&r.then(t=>e(void 0===t?void 0:t),s),o.signal.addEventListener("abort",()=>{(!i.ignoreFetchAbort||i.allowStaleOnFetchAbort)&&(e(void 0),i.allowStaleOnFetchAbort&&(e=t=>l(t,!0)))})}).then(l,t=>(i.status&&(i.status.fetchRejected=!0,i.status.fetchError=t),a(t))),u=Object.assign(f,{__abortController:o,__staleWhileFetching:h,__returned:void 0});return void 0===e?(this.set(t,u,{...n.options,status:void 0}),e=this.#l.get(t)):this.#f[e]=u,u}#b(t){if(!this.#m)return!1;let e=t;return!!e&&e instanceof Promise&&e.hasOwnProperty("__staleWhileFetching")&&e.__abortController instanceof W}async fetch(t,e={}){let{allowStale:i=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet,noDeleteOnStaleGet:h=this.noDeleteOnStaleGet,ttl:o=this.ttl,noDisposeOnSet:r=this.noDisposeOnSet,size:n=0,sizeCalculation:l=this.sizeCalculation,noUpdateTTL:a=this.noUpdateTTL,noDeleteOnFetchRejection:f=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:u=this.allowStaleOnFetchRejection,ignoreFetchAbort:c=this.ignoreFetchAbort,allowStaleOnFetchAbort:d=this.allowStaleOnFetchAbort,context:g,forceRefresh:p=!1,status:w,signal:v}=e;if(!this.#m)return w&&(w.fetch="get"),this.get(t,{allowStale:i,updateAgeOnGet:s,noDeleteOnStaleGet:h,status:w});let S={allowStale:i,updateAgeOnGet:s,noDeleteOnStaleGet:h,ttl:o,noDisposeOnSet:r,size:n,sizeCalculation:l,noUpdateTTL:a,noDeleteOnFetchRejection:f,allowStaleOnFetchRejection:u,allowStaleOnFetchAbort:d,ignoreFetchAbort:c,status:w,signal:v},_=this.#l.get(t);if(void 0===_){w&&(w.fetch="miss");let e=this.#O(t,_,S,g);return e.__returned=e}{let e=this.#f[_];if(this.#b(e)){let t=i&&void 0!==e.__staleWhileFetching;return w&&(w.fetch="inflight",t&&(w.returnedStale=!0)),t?e.__staleWhileFetching:e.__returned=e}let h=this.#T(_);if(!p&&!h)return w&&(w.fetch="hit"),this.#E(_),s&&this.#D(_),w&&this.#G(w,_),e;let o=this.#O(t,_,S,g),r=void 0!==o.__staleWhileFetching&&i;return w&&(w.fetch=h?"stale":"refresh",r&&h&&(w.returnedStale=!0)),r?o.__staleWhileFetching:o.__returned=o}}async forceFetch(t,e={}){let i=await this.fetch(t,e);if(void 0===i)throw new Error("fetch() returned undefined");return i}memo(t,e={}){let i=this.#o;if(!i)throw new Error("no memoMethod provided to constructor");let{context:s,forceRefresh:h,...o}=e,r=this.get(t,o);if(!h&&void 0!==r)return r;let n=i(t,r,{options:o,context:s});return this.set(t,n,o),n}get(t,e={}){let{allowStale:i=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet,noDeleteOnStaleGet:h=this.noDeleteOnStaleGet,status:o}=e,r=this.#l.get(t);if(void 0!==r){let e=this.#f[r],n=this.#b(e);return o&&this.#G(o,r),this.#T(r)?(o&&(o.get="stale"),n?(o&&i&&void 0!==e.__staleWhileFetching&&(o.returnedStale=!0),i?e.__staleWhileFetching:void 0):(h||this.#C(t,"expire"),o&&i&&(o.returnedStale=!0),i?e:void 0)):(o&&(o.get="hit"),n?e.__staleWhileFetching:(this.#E(r),s&&this.#D(r),e))}o&&(o.get="miss")}#k(t,e){this.#c[e]=t,this.#u[t]=e}#E(t){t!==this.#g&&(t===this.#d?this.#d=this.#u[t]:this.#k(this.#c[t],this.#u[t]),this.#k(this.#g,t),this.#g=t)}delete(t){return this.#C(t,"delete")}#C(t,e){let i=!1;if(0!==this.#r){let s=this.#l.get(t);if(void 0!==s)if(i=!0,1===this.#r)this.#I(e);else{this.#L(s);let i=this.#f[s];if(this.#b(i)?i.__abortController.abort(new Error("deleted")):(this.#y||this.#A)&&(this.#y&&this.#i?.(i,t,e),this.#A&&this.#w?.push([i,t,e])),this.#l.delete(t),this.#a[s]=void 0,this.#f[s]=void 0,s===this.#g)this.#g=this.#c[s];else if(s===this.#d)this.#d=this.#u[s];else{let t=this.#c[s];this.#u[t]=this.#u[s];let e=this.#u[s];this.#c[e]=this.#c[s]}this.#r--,this.#p.push(s)}}if(this.#A&&this.#w?.length){let t,e=this.#w;for(;t=e?.shift();)this.#s?.(...t)}return i}clear(){return this.#I("delete")}#I(t){for(let e of this.#z({allowStale:!0})){let i=this.#f[e];if(this.#b(i))i.__abortController.abort(new Error("deleted"));else{let s=this.#a[e];this.#y&&this.#i?.(i,s,t),this.#A&&this.#w?.push([i,s,t])}}if(this.#l.clear(),this.#f.fill(void 0),this.#a.fill(void 0),this.#_&&this.#S&&(this.#_.fill(0),this.#S.fill(0)),this.#v&&this.#v.fill(0),this.#d=0,this.#g=0,this.#p.length=0,this.#n=0,this.#r=0,this.#A&&this.#w){let t,e=this.#w;for(;t=e?.shift();)this.#s?.(...t)}}};export{D as LRUCache};