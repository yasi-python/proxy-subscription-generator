const path=require("path"),fs=require("fs"),os=require("os"),url=require("url"),fsReadFileAsync=fs.promises.readFile;function getDefaultSearchPlaces(e,t){return["package.json",`.${e}rc.json`,`.${e}rc.js`,`.${e}rc.cjs`,...t?[]:[`.${e}rc.mjs`],`.config/${e}rc`,`.config/${e}rc.json`,`.config/${e}rc.js`,`.config/${e}rc.cjs`,...t?[]:[`.config/${e}rc.mjs`],`${e}.config.js`,`${e}.config.cjs`,...t?[]:[`${e}.config.mjs`]]}function parentDir(e){return path.dirname(e)||path.sep}const jsonLoader=(e,t)=>JSON.parse(t),requireFunc="function"==typeof __webpack_require__?__non_webpack_require__:require,defaultLoadersSync=Object.freeze({".js":requireFunc,".json":requireFunc,".cjs":requireFunc,noExt:jsonLoader});module.exports.defaultLoadersSync=defaultLoadersSync;const dynamicImport=async e=>{try{const t=url.pathToFileURL(e).href;return(await import(t)).default}catch(t){try{return requireFunc(e)}catch(e){if("ERR_REQUIRE_ESM"===e.code||e instanceof SyntaxError&&e.toString().includes("Cannot use import statement outside a module"))throw t;throw e}}},defaultLoaders=Object.freeze({".js":dynamicImport,".mjs":dynamicImport,".cjs":dynamicImport,".json":jsonLoader,noExt:jsonLoader});function getOptions(e,t,o){const r={stopDir:os.homedir(),searchPlaces:getDefaultSearchPlaces(e,o),ignoreEmptySearchPlaces:!0,cache:!0,transform:e=>e,packageProp:[e],...t,loaders:{...o?defaultLoadersSync:defaultLoaders,...t.loaders}};return r.searchPlaces.forEach(e=>{const t=path.extname(e)||"noExt",o=r.loaders[t];if(!o)throw new Error(`Missing loader for extension "${e}"`);if("function"!=typeof o)throw new Error(`Loader for extension "${e}" is not a function: Received ${typeof o}.`)}),r}function getPackageProp(e,t){return"string"==typeof e&&e in t?t[e]:(Array.isArray(e)?e:e.split(".")).reduce((e,t)=>void 0===e?e:e[t],t)||null}function validateFilePath(e){if(!e)throw new Error("load must pass a non-empty string")}function validateLoader(e,t){if(!e)throw new Error(`No loader specified for extension "${t}"`);if("function"!=typeof e)throw new Error("loader is not a function")}module.exports.defaultLoaders=defaultLoaders;const makeEmplace=e=>(t,o,r)=>(e&&t.set(o,r),r);module.exports.lilconfig=function(e,t){const{ignoreEmptySearchPlaces:o,loaders:r,packageProp:a,searchPlaces:n,stopDir:c,transform:i,cache:s}=getOptions(e,t??{},!1),f=new Map,l=new Map,p=makeEmplace(s);return{async search(e=process.cwd()){const t={config:null,filepath:""},l=new Set;let p=e;e:for(;;){if(s){const e=f.get(p);if(void 0!==e){for(const t of l)f.set(t,e);return e}l.add(p)}for(const e of n){const n=path.join(p,e);try{await fs.promises.access(n)}catch{continue}const c=String(await fsReadFileAsync(n)),i=path.extname(e)||"noExt",s=r[i];if("package.json"===e){const e=await s(n,c),o=getPackageProp(a,e);if(null!=o){t.config=o,t.filepath=n;break e}continue}const f=""===c.trim();if(!f||!o){f?(t.isEmpty=!0,t.config=void 0):(validateLoader(s,i),t.config=await s(n,c)),t.filepath=n;break e}}if(p===c||p===parentDir(p))break e;p=parentDir(p)}const d=""===t.filepath&&null===t.config?i(null):i(t);if(s)for(const e of l)f.set(e,d);return d},async load(e){validateFilePath(e);const t=path.resolve(process.cwd(),e);if(s&&l.has(t))return l.get(t);const{base:n,ext:c}=path.parse(t),f=c||"noExt",d=r[f];validateLoader(d,f);const u=String(await fsReadFileAsync(t));if("package.json"===n){const e=await d(t,u);return p(l,t,i({config:getPackageProp(a,e),filepath:t}))}const h={config:null,filepath:t},g=""===u.trim();return g&&o?p(l,t,i({config:void 0,filepath:t,isEmpty:!0})):(h.config=g?void 0:await d(t,u),p(l,t,i(g?{...h,isEmpty:g,config:void 0}:h)))},clearLoadCache(){s&&l.clear()},clearSearchCache(){s&&f.clear()},clearCaches(){s&&(l.clear(),f.clear())}}},module.exports.lilconfigSync=function(e,t){const{ignoreEmptySearchPlaces:o,loaders:r,packageProp:a,searchPlaces:n,stopDir:c,transform:i,cache:s}=getOptions(e,t??{},!0),f=new Map,l=new Map,p=makeEmplace(s);return{search(e=process.cwd()){const t={config:null,filepath:""},l=new Set;let p=e;e:for(;;){if(s){const e=f.get(p);if(void 0!==e){for(const t of l)f.set(t,e);return e}l.add(p)}for(const e of n){const n=path.join(p,e);try{fs.accessSync(n)}catch{continue}const c=path.extname(e)||"noExt",i=r[c],s=String(fs.readFileSync(n));if("package.json"===e){const e=i(n,s),o=getPackageProp(a,e);if(null!=o){t.config=o,t.filepath=n;break e}continue}const f=""===s.trim();if(!f||!o){f?(t.isEmpty=!0,t.config=void 0):(validateLoader(i,c),t.config=i(n,s)),t.filepath=n;break e}}if(p===c||p===parentDir(p))break e;p=parentDir(p)}const d=""===t.filepath&&null===t.config?i(null):i(t);if(s)for(const e of l)f.set(e,d);return d},load(e){validateFilePath(e);const t=path.resolve(process.cwd(),e);if(s&&l.has(t))return l.get(t);const{base:n,ext:c}=path.parse(t),f=c||"noExt",d=r[f];validateLoader(d,f);const u=String(fs.readFileSync(t));if("package.json"===n){const e=d(t,u);return i({config:getPackageProp(a,e),filepath:t})}const h={config:null,filepath:t},g=""===u.trim();return g&&o?p(l,t,i({filepath:t,config:void 0,isEmpty:!0})):(h.config=g?void 0:d(t,u),p(l,t,i(g?{...h,isEmpty:g,config:void 0}:h)))},clearLoadCache(){s&&l.clear()},clearSearchCache(){s&&f.clear()},clearCaches(){s&&(l.clear(),f.clear())}}};