"use strict";function _export(e,t){for(var r in t)Object.defineProperty(e,r,{enumerable:!0,get:t[r]})}Object.defineProperty(exports,"__esModule",{value:!0}),_export(exports,{elementSelectorParser:function(){return elementSelectorParser},default:function(){return resolveDefaultsAtRules}});const _postcss=_interop_require_default(require("postcss")),_postcssselectorparser=_interop_require_default(require("postcss-selector-parser")),_featureFlags=require("../featureFlags");function _interop_require_default(e){return e&&e.__esModule?e:{default:e}}let getNode={id:e=>_postcssselectorparser.default.attribute({attribute:"id",operator:"=",value:e.value,quoteMark:'"'})};function minimumImpactSelector(e){let t=e.filter(e=>"pseudo"!==e.type||e.nodes.length>0||e.value.startsWith("::")||[":before",":after",":first-line",":first-letter"].includes(e.value)).reverse(),r=new Set(["tag","class","id","attribute"]),s=t.findIndex(e=>r.has(e.type));if(-1===s)return t.reverse().join("").trim();let l=t[s],o=getNode[l.type]?getNode[l.type](l):l;t=t.slice(0,s);let a=t.findIndex(e=>"combinator"===e.type&&">"===e.value);return-1!==a&&(t.splice(0,a),t.unshift(_postcssselectorparser.default.universal())),[o,...t.reverse()].join("").trim()}let elementSelectorParser=(0,_postcssselectorparser.default)(e=>e.map(e=>minimumImpactSelector(e.split(e=>"combinator"===e.type&&" "===e.value).pop()))),cache=new Map;function extractElementSelector(e){return cache.has(e)||cache.set(e,elementSelectorParser.transformSync(e)),cache.get(e)}function resolveDefaultsAtRules({tailwindConfig:e}){return t=>{let r=new Map,s=new Set;if(t.walkAtRules("defaults",e=>{if(e.nodes&&e.nodes.length>0)return void s.add(e);let t=e.params;r.has(t)||r.set(t,new Set),r.get(t).add(e.parent),e.remove()}),(0,_featureFlags.flagEnabled)(e,"optimizeUniversalDefaults"))for(let e of s){let t=new Map;var l;let s=null!==(l=r.get(e.params))&&void 0!==l?l:[];for(let e of s)for(let r of extractElementSelector(e.selector)){let e=r.includes(":-")||r.includes("::-")||r.includes(":has")?r:"__DEFAULT__";var o;let s=null!==(o=t.get(e))&&void 0!==o?o:new Set;t.set(e,s),s.add(r)}if(0!==t.size){for(let[,r]of t){let t=_postcss.default.rule({source:e.source});t.selectors=[...r],t.append(e.nodes.map(e=>e.clone())),e.before(t)}e.remove()}else e.remove()}else if(s.size){let e=_postcss.default.rule({selectors:["*","::before","::after"]});for(let t of s)e.append(t.nodes),e.parent||t.before(e),e.source||(e.source=t.source),t.remove();let t=e.clone({selectors:["::backdrop"]});e.after(t)}}}