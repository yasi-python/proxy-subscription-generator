import path from"path";import fs from"fs";import postcssrc from"postcss-load-config";import{lilconfig}from"lilconfig";import loadPlugins from"postcss-load-config/src/plugins";import loadOptions from"postcss-load-config/src/options";import tailwind from"../../processTailwindFeatures";import{loadAutoprefixer,loadCssNano,loadPostcss,loadPostcssImport}from"./deps";import{formatNodes,drainStdin,outputFile}from"./utils";import{env}from"../../lib/sharedState";import resolveConfig from"../../../resolveConfig.js";import{createBroadPatternCheck,parseCandidateFiles}from"../../lib/content.js";import{createWatcher}from"./watching.js";import fastGlob from"fast-glob";import{findAtConfigPath}from"../../lib/findAtConfigPath.js";import log from"../../util/log";import{loadConfig}from"../../lib/load-config";import getModuleDependencies from"../../lib/getModuleDependencies";async function loadPostCssPlugins(e){let t=e?await(async()=>{let t=path.resolve(e),{config:n={}}=await lilconfig("postcss").load(t);return n="function"==typeof n?n():Object.assign({},n),n.plugins||(n.plugins=[]),{file:t,plugins:loadPlugins(n,t),options:loadOptions(n,t)}})():await postcssrc(),n=t.plugins,o=n.findIndex(e=>"function"==typeof e&&"tailwindcss"===e.name||"object"==typeof e&&null!==e&&"tailwindcss"===e.postcssPlugin);return[-1===o?[]:n.slice(0,o),-1===o?n:n.slice(o+1),t.options]}function loadBuiltinPostcssPlugins(){let e=loadPostcss(),t="__TAILWIND_RESTORE_IMPORT__: ";return[[n=>{n.walkAtRules("import",n=>{n.params.slice(1).startsWith("tailwindcss/")&&(n.after(e.comment({text:t+n.params})),n.remove())})},loadPostcssImport(),n=>{n.walkComments(n=>{n.text.startsWith(t)&&(n.after(e.atRule({name:"import",params:n.text.replace(t,"")})),n.remove())})}],[],{}]}let state={context:null,watcher:null,changedContent:[],configBag:null,contextDependencies:new Set,contentPaths:[],refreshContentPaths(){this.contentPaths=parseCandidateFiles(this.context,this.context?.tailwindConfig)},get config(){return this.context.tailwindConfig},get contentPatterns(){return{all:this.contentPaths.map(e=>e.pattern),dynamic:this.contentPaths.filter(e=>void 0!==e.glob).map(e=>e.pattern)}},loadConfig(e,t){this.watcher&&e&&this.refreshConfigDependencies();let n=loadConfig(e),o=getModuleDependencies(e);return this.configBag={config:n,dependencies:o,dispose(){for(let e of o)delete require.cache[require.resolve(e)]}},this.configBag.config=resolveConfig(this.configBag.config,{content:{files:[]}}),t?.length>0&&(this.configBag.config.content.files=t),this.configBag.config},refreshConfigDependencies(){env.DEBUG&&console.time("Module dependencies"),this.configBag?.dispose(),env.DEBUG&&console.timeEnd("Module dependencies")},readContentPaths(){let e=[],t=fastGlob.sync(this.contentPatterns.all),n=createBroadPatternCheck(this.contentPatterns.all);for(let o of t)n(o),e.push({content:fs.readFileSync(path.resolve(o),"utf8"),extension:path.extname(o).slice(1)});let o=this.config.content.files.filter(e=>null!==e&&"object"==typeof e);for(let{raw:t,extension:n="html"}of o)e.push({content:t,extension:n});return e},getContext({createContext:e,cliConfigPath:t,root:n,result:o,content:s}){env.DEBUG&&console.time("Searching for config");let i=findAtConfigPath(n,o)??t;if(env.DEBUG&&console.timeEnd("Searching for config"),this.context)return this.context.changedContent=this.changedContent.splice(0),this.context;env.DEBUG&&console.time("Loading config");let a=this.loadConfig(i,s);env.DEBUG&&console.timeEnd("Loading config"),env.DEBUG&&console.time("Creating context"),this.context=e(a,[]),Object.assign(this.context,{userConfigPath:i}),env.DEBUG&&console.timeEnd("Creating context"),env.DEBUG&&console.time("Resolving content paths"),this.refreshContentPaths(),env.DEBUG&&console.timeEnd("Resolving content paths"),this.watcher&&(env.DEBUG&&console.time("Watch new files"),this.watcher.refreshWatchedFiles(),env.DEBUG&&console.timeEnd("Watch new files"));for(let e of this.readContentPaths())this.context.changedContent.push(e);return this.context}};export async function createProcessor(e,t){let n=loadPostcss(),o=e["--input"],s=e["--output"],i=e["--postcss"],a="string"==typeof e["--postcss"]?e["--postcss"]:void 0,[r,c,l]=i?await loadPostCssPlugins(a):loadBuiltinPostcssPlugins();e["--purge"]&&(log.warn("purge-flag-deprecated",["The `--purge` flag has been deprecated.","Please use `--content` instead."]),e["--content"]||(e["--content"]=e["--purge"]));let f=e["--content"]?.split(/(?<!{[^}]+),/)??[],d=()=>({postcssPlugin:"tailwindcss",async Once(e,{result:n}){env.DEBUG&&console.time("Compiling CSS"),await tailwind(({createContext:o})=>(console.error(),console.error("Rebuilding..."),()=>state.getContext({createContext:o,cliConfigPath:t,root:e,result:n,content:f})))(e,n),env.DEBUG&&console.timeEnd("Compiling CSS")}});d.postcss=!0;let p=n([...r,d,!e["--minify"]&&formatNodes,...c,!e["--no-autoprefixer"]&&loadAutoprefixer(),e["--minify"]&&loadCssNano()].filter(Boolean));async function g(){let e=process.hrtime.bigint();return async function(){return"-"===o?drainStdin():o?fs.promises.readFile(path.resolve(o),"utf8"):"@tailwind base; @tailwind components; @tailwind utilities"}().then(e=>p.process(e,{...l,from:o,to:s})).then(e=>{if(!state.watcher)return e;env.DEBUG&&console.time("Recording PostCSS dependencies");for(let t of e.messages)"dependency"===t.type&&state.contextDependencies.add(t.file);return env.DEBUG&&console.timeEnd("Recording PostCSS dependencies"),env.DEBUG&&console.time("Watch new files"),state.watcher.refreshWatchedFiles(),env.DEBUG&&console.timeEnd("Watch new files"),e}).then(e=>{if(s)return Promise.all([outputFile(e.opts.to,e.css),e.map&&outputFile(e.opts.to+".map",e.map.toString())]);process.stdout.write(e.css)}).then(()=>{let t=process.hrtime.bigint();console.error(),console.error("Done in",(t-e)/BigInt(1e6)+"ms.")}).then(()=>{},e=>{if(!state.watcher)return Promise.reject(e);console.error(e)})}return void 0!==o&&"-"!==o&&state.contextDependencies.add(path.resolve(o)),{build:g,watch:async()=>{state.watcher=createWatcher(e,{state:state,async rebuild(e){if(e.some(e=>state.configBag?.dependencies.has(e.file)||state.contextDependencies.has(e.file)))state.context=null;else for(let t of await async function(e){return Promise.all(e.map(async e=>({content:await e.content(),extension:e.extension})))}(e))state.changedContent.push(t);return g()}}),await g()}}}