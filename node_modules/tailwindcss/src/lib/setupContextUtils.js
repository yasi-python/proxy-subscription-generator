import fs from"fs";import url from"url";import postcss from"postcss";import dlv from"dlv";import selectorParser from"postcss-selector-parser";import transformThemeValue from"../util/transformThemeValue";import parseObjectStyles from"../util/parseObjectStyles";import prefixSelector from"../util/prefixSelector";import isPlainObject from"../util/isPlainObject";import escapeClassName from"../util/escapeClassName";import nameClass,{formatClass}from"../util/nameClass";import{coerceValue}from"../util/pluginUtils";import{variantPlugins,corePlugins}from"../corePlugins";import*as sharedState from"./sharedState";import{env}from"./sharedState";import{toPath}from"../util/toPath";import log from"../util/log";import negateValue from"../util/negateValue";import isSyntacticallyValidPropertyValue from"../util/isSyntacticallyValidPropertyValue";import{generateRules,getClassNameFromSelector}from"./generateRules";import{hasContentChanged}from"./cacheInvalidation.js";import{Offsets}from"./offsets.js";import{flagEnabled}from"../featureFlags.js";import{finalizeSelector,formatVariantSelector}from"../util/formatVariantSelector";export const INTERNAL_FEATURES=Symbol();const VARIANT_TYPES={AddVariant:Symbol.for("ADD_VARIANT"),MatchVariant:Symbol.for("MATCH_VARIANT")},VARIANT_INFO={Base:1,Dynamic:2};function prefix(e,t){let a=e.tailwindConfig.prefix;return"function"==typeof a?a(t):a+t}function normalizeOptionTypes({type:e="any",...t}){return{...t,types:[].concat(e).map(e=>Array.isArray(e)?{type:e[0],...e[1]}:{type:e,preferOnConflict:!1})}}function parseVariantFormatString(e){let t=[],a="",r=0;for(let i=0;i<e.length;i++){let n=e[i];if("\\"===n)a+="\\"+e[++i];else if("{"===n)++r,t.push(a.trim()),a="";else if("}"===n){if(--r<0)throw new Error("Your { and } are unbalanced.");t.push(a.trim()),a=""}else a+=n}return a.length>0&&t.push(a.trim()),t=t.filter(e=>""!==e),t}function insertInto(e,t,{before:a=[]}={}){if((a=[].concat(a)).length<=0)return void e.push(t);let r=e.length-1;for(let t of a){let a=e.indexOf(t);-1!==a&&(r=Math.min(r,a))}e.splice(r,0,t)}function parseStyles(e){return Array.isArray(e)?e.flatMap(e=>Array.isArray(e)||isPlainObject(e)?parseObjectStyles(e):e):parseStyles([e])}function getClasses(e,t){return selectorParser(e=>{let a=[];return t&&t(e),e.walkClasses(e=>{a.push(e.value)}),a}).transformSync(e)}function ignoreNot(e){e.walkPseudos(e=>{":not"===e.value&&e.remove()})}function extractCandidates(e,t={containsNonOnDemandable:!1},a=0){let r=[],i=[];"rule"===e.type?i.push(...e.selectors):"atrule"===e.type&&e.walkRules(e=>i.push(...e.selectors));for(let e of i){let a=getClasses(e,ignoreNot);0===a.length&&(t.containsNonOnDemandable=!0);for(let e of a)r.push(e)}return 0===a?[t.containsNonOnDemandable||0===r.length,r]:r}function withIdentifiers(e){return parseStyles(e).flatMap(e=>{let t=new Map,[a,r]=extractCandidates(e);return a&&r.unshift(sharedState.NOT_ON_DEMAND),r.map(a=>(t.has(e)||t.set(e,e),[a,t.get(e)]))})}export function isValidVariantFormatString(e){return e.startsWith("@")||e.includes("&")}export function parseVariant(e){let t=parseVariantFormatString(e=e.replace(/\n+/g,"").replace(/\s{1,}/g," ").trim()).map(e=>{if(!e.startsWith("@"))return({format:t})=>t(e);let[,t,a]=/@(\S*)( .+|[({].*)?/g.exec(e);return({wrap:e})=>e(postcss.atRule({name:t,params:a?.trim()??""}))}).reverse();return e=>{for(let a of t)a(e)}}function buildPluginApi(e,t,{variantList:a,variantMap:r,offsets:i,classList:n}){function s(t,a){return t?dlv(e,t,a):e}function o(e,a){return e===sharedState.NOT_ON_DEMAND?sharedState.NOT_ON_DEMAND:a.respectPrefix?t.tailwindConfig.prefix+e:e}let l=0,c={postcss:postcss,prefix:function(t){return prefixSelector(e.prefix,t)},e:escapeClassName,config:s,theme:function(e,t,a={}){let r=toPath(e),i=s(["theme",...r],t);return transformThemeValue(r[0])(i,a)},corePlugins:t=>Array.isArray(e.corePlugins)?e.corePlugins.includes(t):s(["corePlugins",t],!0),variants:()=>[],addBase(e){for(let[a,r]of withIdentifiers(e)){let e=o(a,{}),n=i.create("base");t.candidateRuleMap.has(e)||t.candidateRuleMap.set(e,[]),t.candidateRuleMap.get(e).push([{sort:n,layer:"base"},r])}},addDefaults(e,a){const r={[`@defaults ${e}`]:a};for(let[e,a]of withIdentifiers(r)){let r=o(e,{});t.candidateRuleMap.has(r)||t.candidateRuleMap.set(r,[]),t.candidateRuleMap.get(r).push([{sort:i.create("defaults"),layer:"defaults"},a])}},addComponents(e,a){a=Object.assign({},{preserveSource:!1,respectPrefix:!0,respectImportant:!1},Array.isArray(a)?{}:a);for(let[r,s]of withIdentifiers(e)){let e=o(r,a);n.add(e),t.candidateRuleMap.has(e)||t.candidateRuleMap.set(e,[]),t.candidateRuleMap.get(e).push([{sort:i.create("components"),layer:"components",options:a},s])}},addUtilities(e,a){a=Object.assign({},{preserveSource:!1,respectPrefix:!0,respectImportant:!0},Array.isArray(a)?{}:a);for(let[r,s]of withIdentifiers(e)){let e=o(r,a);n.add(e),t.candidateRuleMap.has(e)||t.candidateRuleMap.set(e,[]),t.candidateRuleMap.get(e).push([{sort:i.create("utilities"),layer:"utilities",options:a},s])}},matchUtilities:function(a,r){r=normalizeOptionTypes({respectPrefix:!0,respectImportant:!0,modifiers:!1,...r});let s=i.create("utilities");for(let c in a){let p=o(c,r),f=a[c];function l(t,{isOnlyPlugin:a}){let[i,n,s]=coerceValue(r.types,t,r,e);if(void 0===i)return[];if(!r.types.some(({type:e})=>e===n)){if(!a)return[];log.warn([`Unnecessary typehint \`${n}\` in \`${c}-${t}\`.`,`You can safely update it to \`${c}-${t.replace(n+":","")}\`.`])}if(!isSyntacticallyValidPropertyValue(i))return[];let o={get modifier(){return r.modifiers||log.warn(`modifier-used-without-options-for-${c}`,["Your plugin must set `modifiers: true` in its options to support modifiers."]),s}},l=flagEnabled(e,"generalizedModifiers");return[].concat(l?f(i,o):f(i)).filter(Boolean).map(e=>({[nameClass(c,t)]:e}))}n.add([p,r]);let u=[{sort:s,layer:"utilities",options:r},l];t.candidateRuleMap.has(p)||t.candidateRuleMap.set(p,[]),t.candidateRuleMap.get(p).push(u)}},matchComponents:function(a,r){r=normalizeOptionTypes({respectPrefix:!0,respectImportant:!1,modifiers:!1,...r});let s=i.create("components");for(let c in a){let p=o(c,r),f=a[c];function l(t,{isOnlyPlugin:a}){let[i,n,s]=coerceValue(r.types,t,r,e);if(void 0===i)return[];if(!r.types.some(({type:e})=>e===n)){if(!a)return[];log.warn([`Unnecessary typehint \`${n}\` in \`${c}-${t}\`.`,`You can safely update it to \`${c}-${t.replace(n+":","")}\`.`])}if(!isSyntacticallyValidPropertyValue(i))return[];let o={get modifier(){return r.modifiers||log.warn(`modifier-used-without-options-for-${c}`,["Your plugin must set `modifiers: true` in its options to support modifiers."]),s}},l=flagEnabled(e,"generalizedModifiers");return[].concat(l?f(i,o):f(i)).filter(Boolean).map(e=>({[nameClass(c,t)]:e}))}n.add([p,r]);let u=[{sort:s,layer:"components",options:r},l];t.candidateRuleMap.has(p)||t.candidateRuleMap.set(p,[]),t.candidateRuleMap.get(p).push(u)}},addVariant(e,i,n={}){i=[].concat(i).map(t=>{if("string"!=typeof t)return(a={})=>{let{args:r,modifySelectors:i,container:s,separator:o,wrap:l,format:c}=a,p=t(Object.assign({modifySelectors:i,container:s,separator:o},n.type===VARIANT_TYPES.MatchVariant&&{args:r,wrap:l,format:c}));if("string"==typeof p&&!isValidVariantFormatString(p))throw new Error(`Your custom variant \`${e}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`);return Array.isArray(p)?p.filter(e=>"string"==typeof e).map(e=>parseVariant(e)):p&&"string"==typeof p&&parseVariant(p)(a)};if(!isValidVariantFormatString(t))throw new Error(`Your custom variant \`${e}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`);return parseVariant(t)}),insertInto(a,e,n),r.set(e,i),t.variantOptions.set(e,n)},matchVariant(t,a,r){let i=r?.id??++l,n="@"===t,s=flagEnabled(e,"generalizedModifiers");for(let[e,o]of Object.entries(r?.values??{}))"DEFAULT"!==e&&c.addVariant(n?`${t}${e}`:`${t}-${e}`,({args:e,container:t})=>a(o,s?{modifier:e?.modifier,container:t}:{container:t}),{...r,value:o,id:i,type:VARIANT_TYPES.MatchVariant,variantInfo:VARIANT_INFO.Base});let o="DEFAULT"in(r?.values??{});c.addVariant(t,({args:e,container:t})=>e?.value!==sharedState.NONE||o?a(e?.value===sharedState.NONE?r.values.DEFAULT:e?.value??("string"==typeof e?e:""),s?{modifier:e?.modifier,container:t}:{container:t}):null,{...r,id:i,type:VARIANT_TYPES.MatchVariant,variantInfo:VARIANT_INFO.Dynamic})}};return c}let fileModifiedMapCache=new WeakMap;export function getFileModifiedMap(e){return fileModifiedMapCache.has(e)||fileModifiedMapCache.set(e,new Map),fileModifiedMapCache.get(e)}function trackModified(e,t){let a=!1,r=new Map;for(let i of e){if(!i)continue;let e=url.parse(i),n=e.hash?e.href.replace(e.hash,""):e.href;n=e.search?n.replace(e.search,""):n;let s=fs.statSync(decodeURIComponent(n),{throwIfNoEntry:!1})?.mtimeMs;s&&((!t.has(i)||s>t.get(i))&&(a=!0),r.set(i,s))}return[a,r]}function extractVariantAtRules(e){e.walkAtRules(e=>{["responsive","variants"].includes(e.name)&&(extractVariantAtRules(e),e.before(e.nodes),e.remove())})}function collectLayerPlugins(e){let t=[];return e.each(e=>{"atrule"===e.type&&["responsive","variants"].includes(e.name)&&(e.name="layer",e.params="utilities")}),e.walkAtRules("layer",e=>{if(extractVariantAtRules(e),"base"===e.params){for(let a of e.nodes)t.push(function({addBase:e}){e(a,{respectPrefix:!1})});e.remove()}else if("components"===e.params){for(let a of e.nodes)t.push(function({addComponents:e}){e(a,{respectPrefix:!1,preserveSource:!0})});e.remove()}else if("utilities"===e.params){for(let a of e.nodes)t.push(function({addUtilities:e}){e(a,{respectPrefix:!1,preserveSource:!0})});e.remove()}}),t}function resolvePlugins(e,t){let a=Object.entries({...variantPlugins,...corePlugins}).map(([t,a])=>e.tailwindConfig.corePlugins.includes(t)?a:null).filter(Boolean),r=e.tailwindConfig.plugins.map(e=>(e.__isOptionsFunction&&(e=e()),"function"==typeof e?e:e.handler)),i=collectLayerPlugins(t),n=[variantPlugins.childVariant,variantPlugins.pseudoElementVariants,variantPlugins.pseudoClassVariants,variantPlugins.hasVariants,variantPlugins.ariaVariants,variantPlugins.dataVariants],s=[variantPlugins.supportsVariants,variantPlugins.reducedMotionVariants,variantPlugins.prefersContrastVariants,variantPlugins.screenVariants,variantPlugins.orientationVariants,variantPlugins.directionVariants,variantPlugins.darkVariants,variantPlugins.forcedColorsVariants,variantPlugins.printVariant];return("class"===e.tailwindConfig.darkMode||Array.isArray(e.tailwindConfig.darkMode)&&"class"===e.tailwindConfig.darkMode[0])&&(s=[variantPlugins.supportsVariants,variantPlugins.reducedMotionVariants,variantPlugins.prefersContrastVariants,variantPlugins.darkVariants,variantPlugins.screenVariants,variantPlugins.orientationVariants,variantPlugins.directionVariants,variantPlugins.forcedColorsVariants,variantPlugins.printVariant]),[...a,...n,...r,...s,...i]}function registerPlugins(e,t){let a=[],r=new Map;t.variantMap=r;let i=new Offsets;t.offsets=i;let n=new Set,s=buildPluginApi(t.tailwindConfig,t,{variantList:a,variantMap:r,offsets:i,classList:n});for(let t of e)if(Array.isArray(t))for(let e of t)e(s);else t?.(s);i.recordVariants(a,e=>r.get(e).length);for(let[e,a]of r.entries())t.variantMap.set(e,a.map((t,a)=>[i.forVariant(e,a),t]));let o=(t.tailwindConfig.safelist??[]).filter(Boolean);if(o.length>0){let e=[];for(let a of o)"string"!=typeof a?a instanceof RegExp?log.warn("root-regex",["Regular expressions in `safelist` work differently in Tailwind CSS v3.0.","Update your `safelist` configuration to eliminate this warning.","https://tailwindcss.com/docs/content-configuration#safelisting-classes"]):e.push(a):t.changedContent.push({content:a,extension:"html"});if(e.length>0){let a=new Map,r=t.tailwindConfig.prefix.length,i=e.some(e=>e.pattern.source.includes("!"));for(let s of n){let n=Array.isArray(s)?(()=>{let[e,a]=s,n=Object.keys(a?.values??{}).map(t=>formatClass(e,t));return a?.supportsNegativeValues&&(n=[...n,...n.map(e=>"-"+e)],n=[...n,...n.map(e=>e.slice(0,r)+"-"+e.slice(r))]),a.types.some(({type:e})=>"color"===e)&&(n=[...n,...n.flatMap(e=>Object.keys(t.tailwindConfig.theme.opacity).map(t=>`${e}/${t}`))]),i&&a?.respectImportant&&(n=[...n,...n.map(e=>"!"+e)]),n})():[s];for(let r of n)for(let{pattern:i,variants:n=[]}of e)if(i.lastIndex=0,a.has(i)||a.set(i,0),i.test(r)){a.set(i,a.get(i)+1),t.changedContent.push({content:r,extension:"html"});for(let e of n)t.changedContent.push({content:e+t.tailwindConfig.separator+r,extension:"html"})}}for(let[e,t]of a.entries())0===t&&log.warn([`The safelist pattern \`${e}\` doesn't match any Tailwind CSS classes.`,"Fix this pattern or remove it from your `safelist` configuration.","https://tailwindcss.com/docs/content-configuration#safelisting-classes"])}}let l=[].concat(t.tailwindConfig.darkMode??"media")[1]??"dark",c=[prefix(t,l),prefix(t,"group"),prefix(t,"peer")];t.getClassOrder=function(e){let a=[...e].sort((e,t)=>e===t?0:e<t?-1:1),r=new Map(a.map(e=>[e,null])),i=generateRules(new Set(a),t,!0);i=t.offsets.sort(i);let n=BigInt(c.length);for(const[,e]of i){let t=e.raws.tailwind.candidate;r.set(t,r.get(t)??n++)}return e.map(e=>{let t=r.get(e)??null,a=c.indexOf(e);return null===t&&-1!==a&&(t=BigInt(a)),[e,t]})},t.getClassList=function(e={}){let a=[];for(let r of n)if(Array.isArray(r)){let[i,n]=r,s=[],o=Object.keys(n?.modifiers??{});n?.types?.some(({type:e})=>"color"===e)&&o.push(...Object.keys(t.tailwindConfig.theme.opacity??{}));let l={modifiers:o},c=e.includeMetadata&&o.length>0;for(let[e,t]of Object.entries(n?.values??{})){if(null==t)continue;let r=formatClass(i,e);if(a.push(c?[r,l]:r),n?.supportsNegativeValues&&negateValue(t)){let t=formatClass(i,`-${e}`);s.push(c?[t,l]:t)}}a.push(...s)}else a.push(r);return a},t.getVariants=function(){let e=Math.random().toString(36).substring(7).toUpperCase(),a=[];for(let[r,i]of t.variantOptions.entries())i.variantInfo!==VARIANT_INFO.Base&&a.push({name:r,isArbitrary:i.type===Symbol.for("MATCH_VARIANT"),values:Object.keys(i.values??{}),hasDash:"@"!==r,selectors({modifier:a,value:n}={}){let s=`TAILWINDPLACEHOLDER${e}`,o=postcss.rule({selector:`.${s}`}),l=postcss.root({nodes:[o.clone()]}),c=l.toString(),p=(t.variantMap.get(r)??[]).flatMap(([e,t])=>t),f=[];for(let e of p){let r=[],s={args:{modifier:a,value:i.values?.[n]??n},separator:t.tailwindConfig.separator,modifySelectors:e=>(l.each(t=>{"rule"===t.type&&(t.selectors=t.selectors.map(t=>e({get className(){return getClassNameFromSelector(t)},selector:t})))}),l),format(e){r.push(e)},wrap(e){r.push(`@${e.name} ${e.params} { & }`)},container:l},o=e(s);if(r.length>0&&f.push(r),Array.isArray(o))for(let e of o)r=[],e(s),f.push(r)}let u=[];c!==l.toString()&&(l.walkRules(e=>{let a=e.selector,i=selectorParser(e=>{e.walkClasses(e=>{e.value=`${r}${t.tailwindConfig.separator}${e.value}`})}).processSync(a);u.push(a.replace(i,"&").replace(s,"&"))}),l.walkAtRules(e=>{u.push(`@${e.name} (${e.params}) { & }`)}));let d=!(n in(i.values??{})),m=i[INTERNAL_FEATURES]??{},g=!d&&!1!==m.respectPrefix;f=f.map(e=>e.map(e=>({format:e,respectPrefix:g}))),u=u.map(e=>({format:e,respectPrefix:g}));let h={candidate:s,context:t},y=f.map(e=>finalizeSelector(`.${s}`,formatVariantSelector(e,h),h).replace(`.${s}`,"&").replace("{ & }","").trim());return u.length>0&&y.push(formatVariantSelector(u,h).toString().replace(`.${s}`,"&")),y}});return a}}function markInvalidUtilityCandidate(e,t){e.classCache.has(t)&&(e.notClassCache.add(t),e.classCache.delete(t),e.applyClassCache.delete(t),e.candidateRuleMap.delete(t),e.candidateRuleCache.delete(t),e.stylesheetCache=null)}function markInvalidUtilityNode(e,t){let a=t.raws.tailwind.candidate;if(a){for(const t of e.ruleCache)t[1].raws.tailwind.candidate===a&&e.ruleCache.delete(t);markInvalidUtilityCandidate(e,a)}}export function createContext(e,t=[],a=postcss.root()){let r={disposables:[],ruleCache:new Set,candidateRuleCache:new Map,classCache:new Map,applyClassCache:new Map,notClassCache:new Set(e.blocklist??[]),postCssNodeCache:new Map,candidateRuleMap:new Map,tailwindConfig:e,changedContent:t,variantMap:new Map,stylesheetCache:null,variantOptions:new Map,markInvalidUtilityCandidate:e=>markInvalidUtilityCandidate(r,e),markInvalidUtilityNode:e=>markInvalidUtilityNode(r,e)};return registerPlugins(resolvePlugins(r,a),r),r}let contextMap=sharedState.contextMap,configContextMap=sharedState.configContextMap,contextSourcesMap=sharedState.contextSourcesMap;export function getContext(e,t,a,r,i,n){let s,o=t.opts.from,l=null!==r;if(env.DEBUG&&console.log("Source path:",o),l&&contextMap.has(o))s=contextMap.get(o);else if(configContextMap.has(i)){let e=configContextMap.get(i);contextSourcesMap.get(e).add(o),contextMap.set(o,e),s=e}let c=hasContentChanged(o,e);if(s){let[e,t]=trackModified([...n],getFileModifiedMap(s));if(!e&&!c)return[s,!1,t]}if(contextMap.has(o)){let e=contextMap.get(o);if(contextSourcesMap.has(e)&&(contextSourcesMap.get(e).delete(o),0===contextSourcesMap.get(e).size)){contextSourcesMap.delete(e);for(let[t,a]of configContextMap)a===e&&configContextMap.delete(t);for(let t of e.disposables.splice(0))t(e)}}env.DEBUG&&console.log("Setting up new context...");let p=createContext(a,[],e);Object.assign(p,{userConfigPath:r});let[,f]=trackModified([...n],getFileModifiedMap(p));return configContextMap.set(i,p),contextMap.set(o,p),contextSourcesMap.has(p)||contextSourcesMap.set(p,new Set),contextSourcesMap.get(p).add(o),[p,!0,f]}