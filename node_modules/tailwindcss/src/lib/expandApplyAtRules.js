import postcss from"postcss";import parser from"postcss-selector-parser";import{resolveMatches}from"./generateRules";import escapeClassName from"../util/escapeClassName";import{applyImportantSelector}from"../util/applyImportantSelector";import{movePseudos}from"../util/pseudoElements";function extractClasses(e){let t=new Map;postcss.root({nodes:[e.clone()]}).walkRules(e=>{parser(e=>{e.walkClasses(e=>{let s=e.parent.toString(),r=t.get(s);r||t.set(s,r=new Set),r.add(e.value)})}).processSync(e.selector)});let s=Array.from(t.values(),e=>Array.from(e)),r=s.flat();return Object.assign(r,{groups:s})}let selectorExtractor=parser();function extractSelectors(e){return selectorExtractor.astSync(e)}function extractBaseCandidates(e,t){let s=new Set;for(let r of e)s.add(r.split(t).pop());return Array.from(s)}function prefix(e,t){let s=e.tailwindConfig.prefix;return"function"==typeof s?s(t):s+t}function*pathToRoot(e){for(yield e;e.parent;)yield e.parent,e=e.parent}function shallowClone(e,t={}){let s=e.nodes;e.nodes=[];let r=e.clone(t);return e.nodes=s,r}function nestedClone(e){for(let t of pathToRoot(e))if(e!==t){if("root"===t.type)break;e=shallowClone(t,{nodes:[e]})}return e}function buildLocalApplyCache(e,t){let s=new Map;return e.walkRules(e=>{for(let t of pathToRoot(e))if(void 0!==t.raws.tailwind?.layer)return;let r=nestedClone(e),a=t.offsets.create("user");for(let t of extractClasses(e)){let e=s.get(t)||[];s.set(t,e),e.push([{layer:"user",sort:a,important:!1},r])}}),s}function buildApplyCache(e,t){for(let s of e){if(t.notClassCache.has(s)||t.applyClassCache.has(s))continue;if(t.classCache.has(s)){t.applyClassCache.set(s,t.classCache.get(s).map(([e,t])=>[e,t.clone()]));continue}let e=Array.from(resolveMatches(s,t));0!==e.length?t.applyClassCache.set(s,e):t.notClassCache.add(s)}return t.applyClassCache}function lazyCache(e){let t=null;return{get:s=>(t=t||e(),t.get(s)),has:s=>(t=t||e(),t.has(s))}}function combineCaches(e){return{get:t=>e.flatMap(e=>e.get(t)||[]),has:t=>e.some(e=>e.has(t))}}function extractApplyCandidates(e){let t=e.split(/[\s\t\n]+/g);return"!important"===t[t.length-1]?[t.slice(0,-1),!0]:[t,!1]}function processApply(e,t,s){let r=new Set,a=[];if(e.walkAtRules("apply",e=>{let[t]=extractApplyCandidates(e.params);for(let e of t)r.add(e);a.push(e)}),0===a.length)return;let o=combineCaches([s,buildApplyCache(r,t)]);function l(e,t,s){let r=extractSelectors(e),a=extractSelectors(t),o=extractSelectors(`.${escapeClassName(s)}`).nodes[0].nodes[0];return r.each(e=>{let t=new Set;a.each(s=>{let r=!1;(s=s.clone()).walkClasses(a=>{a.value===o.value&&(r||(a.replaceWith(...e.nodes.map(e=>e.clone())),t.add(s),r=!0))})});for(let e of t){let t=[[]];for(let s of e.nodes)if("combinator"===s.type)t.push(s),t.push([]);else{t[t.length-1].push(s)}e.nodes=[];for(let s of t)Array.isArray(s)&&s.sort((e,t)=>"tag"===e.type&&"class"===t.type?-1:"class"===e.type&&"tag"===t.type?1:"class"===e.type&&"pseudo"===t.type&&t.value.startsWith("::")?-1:"pseudo"===e.type&&e.value.startsWith("::")&&"class"===t.type?1:0),e.nodes=e.nodes.concat(s)}e.replaceWith(...t)}),r.toString()}let n=new Map;for(let e of a){let[s]=n.get(e.parent)||[[],e.source];n.set(e.parent,[s,e.source]);let[r,a]=extractApplyCandidates(e.params);if("atrule"===e.parent.type){if("screen"===e.parent.name){let t=e.parent.params;throw e.error(`@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${r.map(e=>`${t}:${e}`).join(" ")} instead.`)}throw e.error(`@apply is not supported within nested at-rules like @${e.parent.name}. You can fix this by un-nesting @${e.parent.name}.`)}for(let l of r){if([prefix(t,"group"),prefix(t,"peer")].includes(l))throw e.error(`@apply should not be used with the '${l}' utility`);if(!o.has(l))throw e.error(`The \`${l}\` class does not exist. If \`${l}\` is a custom class, make sure it is defined within a \`@layer\` directive.`);let r=o.get(l);for(let[,t]of r)"atrule"!==t.type&&t.walkRules(()=>{throw e.error([`The \`${l}\` class cannot be used with \`@apply\` because \`@apply\` does not currently support nested CSS.`,"Rewrite the selector without nesting or configure the `tailwindcss/nesting` plugin:","https://tailwindcss.com/docs/using-with-preprocessors#nesting"].join("\n"))});s.push([l,a,r])}}for(let[e,[s,r]]of n){let a=[];for(let[o,n,p]of s){let s=[o,...extractBaseCandidates([o],t.tailwindConfig.separator)];for(let[i,c]of p){let p=extractClasses(e),u=extractClasses(c);if(u=u.groups.filter(e=>e.some(e=>s.includes(e))).flat(),u=u.concat(extractBaseCandidates(u,t.tailwindConfig.separator)),p.some(e=>u.includes(e)))throw c.error(`You cannot \`@apply\` the \`${o}\` utility here because it creates a circular dependency.`);let f=postcss.root({nodes:[c.clone()]});f.walk(e=>{e.source=r}),("atrule"!==c.type||"atrule"===c.type&&"keyframes"!==c.name)&&f.walkRules(s=>{if(!extractClasses(s).some(e=>e===o))return void s.remove();let r="string"==typeof t.tailwindConfig.important?t.tailwindConfig.important:null,a=void 0!==e.raws.tailwind&&r&&0===e.selector.indexOf(r)?e.selector.slice(r.length):e.selector;""===a&&(a=e.selector),s.selector=l(a,s.selector,o),r&&a!==e.selector&&(s.selector=applyImportantSelector(s.selector,r)),s.walkDecls(e=>{e.important=i.important||n});let p=parser().astSync(s.selector);p.each(e=>movePseudos(e)),s.selector=p.toString()}),f.nodes[0]&&a.push([i.sort,f.nodes[0]])}}let o=t.offsets.sort(a).map(e=>e[1]);e.after(o)}for(let e of a)e.parent.nodes.length>1?e.remove():e.parent.remove();processApply(e,t,s)}export default function expandApplyAtRules(e){return t=>{let s=lazyCache(()=>buildLocalApplyCache(t,e));processApply(t,e,s)}}