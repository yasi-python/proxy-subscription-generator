const DIRECTIONS=new Set(["normal","reverse","alternate","alternate-reverse"]),PLAY_STATES=new Set(["running","paused"]),FILL_MODES=new Set(["none","forwards","backwards","both"]),ITERATION_COUNTS=new Set(["infinite"]),TIMINGS=new Set(["linear","ease","ease-in","ease-out","ease-in-out","step-start","step-end"]),TIMING_FNS=["cubic-bezier","steps"],COMMA=/\,(?![^(]*\))/g,SPACE=/\ +(?![^(]*\))/g,TIME=/^(-?[\d.]+m?s)$/,DIGIT=/^(\d+)$/;export default function parseAnimationValue(e){return e.split(COMMA).map(e=>{let a=e.trim(),t={value:a},I=a.split(SPACE),n=new Set;for(let e of I)!n.has("DIRECTIONS")&&DIRECTIONS.has(e)?(t.direction=e,n.add("DIRECTIONS")):!n.has("PLAY_STATES")&&PLAY_STATES.has(e)?(t.playState=e,n.add("PLAY_STATES")):!n.has("FILL_MODES")&&FILL_MODES.has(e)?(t.fillMode=e,n.add("FILL_MODES")):n.has("ITERATION_COUNTS")||!ITERATION_COUNTS.has(e)&&!DIGIT.test(e)?!n.has("TIMING_FUNCTION")&&TIMINGS.has(e)||!n.has("TIMING_FUNCTION")&&TIMING_FNS.some(a=>e.startsWith(`${a}(`))?(t.timingFunction=e,n.add("TIMING_FUNCTION")):!n.has("DURATION")&&TIME.test(e)?(t.duration=e,n.add("DURATION")):!n.has("DELAY")&&TIME.test(e)?(t.delay=e,n.add("DELAY")):n.has("NAME")?(t.unknown||(t.unknown=[]),t.unknown.push(e)):(t.name=e,n.add("NAME")):(t.iterationCount=e,n.add("ITERATION_COUNTS"));return t})}