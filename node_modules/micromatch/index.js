"use strict";const util=require("util"),braces=require("braces"),picomatch=require("picomatch"),utils=require("picomatch/lib/utils"),isEmptyString=t=>""===t||"./"===t,hasBraces=t=>{const e=t.indexOf("{");return e>-1&&t.indexOf("}",e)>-1},micromatch=(t,e,r)=>{e=[].concat(e),t=[].concat(t);let c=new Set,o=new Set,i=new Set,a=0,n=t=>{i.add(t.output),r&&r.onResult&&r.onResult(t)};for(let i=0;i<e.length;i++){let s=picomatch(String(e[i]),{...r,onResult:n},!0),m=s.state.negated||s.state.negatedExtglob;m&&a++;for(let e of t){let t=s(e,!0);(m?!t.isMatch:t.isMatch)&&(m?c.add(t.output):(c.delete(t.output),o.add(t.output)))}}let s=(a===e.length?[...i]:[...o]).filter(t=>!c.has(t));if(r&&0===s.length){if(!0===r.failglob)throw new Error(`No matches found for "${e.join(", ")}"`);if(!0===r.nonull||!0===r.nullglob)return r.unescape?e.map(t=>t.replace(/\\/g,"")):e}return s};micromatch.match=micromatch,micromatch.matcher=(t,e)=>picomatch(t,e),micromatch.any=micromatch.isMatch=(t,e,r)=>picomatch(e,r)(t),micromatch.not=(t,e,r={})=>{e=[].concat(e).map(String);let c=new Set,o=[],i=new Set(micromatch(t,e,{...r,onResult:t=>{r.onResult&&r.onResult(t),o.push(t.output)}}));for(let t of o)i.has(t)||c.add(t);return[...c]},micromatch.contains=(t,e,r)=>{if("string"!=typeof t)throw new TypeError(`Expected a string: "${util.inspect(t)}"`);if(Array.isArray(e))return e.some(e=>micromatch.contains(t,e,r));if("string"==typeof e){if(isEmptyString(t)||isEmptyString(e))return!1;if(t.includes(e)||t.startsWith("./")&&t.slice(2).includes(e))return!0}return micromatch.isMatch(t,e,{...r,contains:!0})},micromatch.matchKeys=(t,e,r)=>{if(!utils.isObject(t))throw new TypeError("Expected the first argument to be an object");let c=micromatch(Object.keys(t),e,r),o={};for(let e of c)o[e]=t[e];return o},micromatch.some=(t,e,r)=>{let c=[].concat(t);for(let t of[].concat(e)){let e=picomatch(String(t),r);if(c.some(t=>e(t)))return!0}return!1},micromatch.every=(t,e,r)=>{let c=[].concat(t);for(let t of[].concat(e)){let e=picomatch(String(t),r);if(!c.every(t=>e(t)))return!1}return!0},micromatch.all=(t,e,r)=>{if("string"!=typeof t)throw new TypeError(`Expected a string: "${util.inspect(t)}"`);return[].concat(e).every(e=>picomatch(e,r)(t))},micromatch.capture=(t,e,r)=>{let c=utils.isWindows(r),o=picomatch.makeRe(String(t),{...r,capture:!0}).exec(c?utils.toPosixSlashes(e):e);if(o)return o.slice(1).map(t=>void 0===t?"":t)},micromatch.makeRe=(...t)=>picomatch.makeRe(...t),micromatch.scan=(...t)=>picomatch.scan(...t),micromatch.parse=(t,e)=>{let r=[];for(let c of[].concat(t||[]))for(let t of braces(String(c),e))r.push(picomatch.parse(t,e));return r},micromatch.braces=(t,e)=>{if("string"!=typeof t)throw new TypeError("Expected a string");return e&&!0===e.nobrace||!hasBraces(t)?[t]:braces(t,e)},micromatch.braceExpand=(t,e)=>{if("string"!=typeof t)throw new TypeError("Expected a string");return micromatch.braces(t,{...e,expand:!0})},micromatch.hasBraces=hasBraces,module.exports=micromatch;