import{signals}from"./signals.js";export{signals};const processOk=t=>!!t&&"object"==typeof t&&"function"==typeof t.removeListener&&"function"==typeof t.emit&&"function"==typeof t.reallyExit&&"function"==typeof t.listeners&&"function"==typeof t.kill&&"number"==typeof t.pid&&"function"==typeof t.on,kExitEmitter=Symbol.for("signal-exit emitter"),global=globalThis,ObjectDefineProperty=Object.defineProperty.bind(Object);class Emitter{emitted={afterExit:!1,exit:!1};listeners={afterExit:[],exit:[]};count=0;id=Math.random();constructor(){if(global[kExitEmitter])return global[kExitEmitter];ObjectDefineProperty(global,kExitEmitter,{value:this,writable:!1,enumerable:!1,configurable:!1})}on(t,e){this.listeners[t].push(e)}removeListener(t,e){const i=this.listeners[t],s=i.indexOf(e);-1!==s&&(0===s&&1===i.length?i.length=0:i.splice(s,1))}emit(t,e,i){if(this.emitted[t])return!1;this.emitted[t]=!0;let s=!1;for(const o of this.listeners[t])s=!0===o(e,i)||s;return"exit"===t&&(s=this.emit("afterExit",e,i)||s),s}}class SignalExitBase{}const signalExitWrap=t=>({onExit:(e,i)=>t.onExit(e,i),load:()=>t.load(),unload:()=>t.unload()});class SignalExitFallback extends SignalExitBase{onExit(){return()=>{}}load(){}unload(){}}class SignalExit extends SignalExitBase{#t="win32"===process.platform?"SIGINT":"SIGHUP";#e=new Emitter;#i;#s;#o;#r={};#n=!1;constructor(t){super(),this.#i=t,this.#r={};for(const e of signals)this.#r[e]=()=>{const i=this.#i.listeners(e);let{count:s}=this.#e;const o=t;if("object"==typeof o.__signal_exit_emitter__&&"number"==typeof o.__signal_exit_emitter__.count&&(s+=o.__signal_exit_emitter__.count),i.length===s){this.unload();const i=this.#e.emit("exit",null,e),s="SIGHUP"===e?this.#t:e;i||t.kill(t.pid,s)}};this.#o=t.reallyExit,this.#s=t.emit}onExit(t,e){if(!processOk(this.#i))return()=>{};!1===this.#n&&this.load();const i=e?.alwaysLast?"afterExit":"exit";return this.#e.on(i,t),()=>{this.#e.removeListener(i,t),0===this.#e.listeners.exit.length&&0===this.#e.listeners.afterExit.length&&this.unload()}}load(){if(!this.#n){this.#n=!0,this.#e.count+=1;for(const t of signals)try{const e=this.#r[t];e&&this.#i.on(t,e)}catch(t){}this.#i.emit=(t,...e)=>this.#l(t,...e),this.#i.reallyExit=t=>this.#a(t)}}unload(){this.#n&&(this.#n=!1,signals.forEach(t=>{const e=this.#r[t];if(!e)throw new Error("Listener not defined for signal: "+t);try{this.#i.removeListener(t,e)}catch(t){}}),this.#i.emit=this.#s,this.#i.reallyExit=this.#o,this.#e.count-=1)}#a(t){return processOk(this.#i)?(this.#i.exitCode=t||0,this.#e.emit("exit",this.#i.exitCode,null),this.#o.call(this.#i,this.#i.exitCode)):0}#l(t,...e){const i=this.#s;if("exit"===t&&processOk(this.#i)){"number"==typeof e[0]&&(this.#i.exitCode=e[0]);const s=i.call(this.#i,t,...e);return this.#e.emit("exit",this.#i.exitCode,null),s}return i.call(this.#i,t,...e)}}const process=globalThis.process;export const{onExit:onExit,load:load,unload:unload}=signalExitWrap(processOk(process)?new SignalExit(process):new SignalExitFallback);