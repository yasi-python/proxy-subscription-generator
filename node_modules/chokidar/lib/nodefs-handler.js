"use strict";const fs=require("fs"),sysPath=require("path"),{promisify:promisify}=require("util"),isBinaryPath=require("is-binary-path"),{isWindows:isWindows,isLinux:isLinux,EMPTY_FN:EMPTY_FN,EMPTY_STR:EMPTY_STR,KEY_LISTENERS:KEY_LISTENERS,KEY_ERR:KEY_ERR,KEY_RAW:KEY_RAW,HANDLER_KEYS:HANDLER_KEYS,EV_CHANGE:EV_CHANGE,EV_ADD:EV_ADD,EV_ADD_DIR:EV_ADD_DIR,EV_ERROR:EV_ERROR,STR_DATA:STR_DATA,STR_END:STR_END,BRACE_START:BRACE_START,STAR:STAR}=require("./constants"),THROTTLE_MODE_WATCH="watch",open=promisify(fs.open),stat=promisify(fs.stat),lstat=promisify(fs.lstat),close=promisify(fs.close),fsrealpath=promisify(fs.realpath),statMethods={lstat:lstat,stat:stat},foreach=(t,s)=>{t instanceof Set?t.forEach(s):s(t)},addAndConvert=(t,s,e)=>{let i=t[s];i instanceof Set||(t[s]=i=new Set([i])),i.add(e)},clearItem=t=>s=>{const e=t[s];e instanceof Set?e.clear():delete t[s]},delFromSet=(t,s,e)=>{const i=t[s];i instanceof Set?i.delete(e):i===e&&delete t[s]},isEmptySet=t=>t instanceof Set?0===t.size:!t,FsWatchInstances=new Map;function createFsWatchInstance(t,s,e,i,a){const r=(s,i)=>{e(t),a(s,i,{watchedPath:t}),i&&t!==i&&fsWatchBroadcast(sysPath.resolve(t,i),KEY_LISTENERS,sysPath.join(t,i))};try{return fs.watch(t,s,r)}catch(t){i(t)}}const fsWatchBroadcast=(t,s,e,i,a)=>{const r=FsWatchInstances.get(t);r&&foreach(r[s],t=>{t(e,i,a)})},setFsWatchListener=(t,s,e,i)=>{const{listener:a,errHandler:r,rawEmitter:n}=i;let h,o=FsWatchInstances.get(s);if(!e.persistent)return h=createFsWatchInstance(t,e,a,r,n),h.close.bind(h);if(o)addAndConvert(o,KEY_LISTENERS,a),addAndConvert(o,KEY_ERR,r),addAndConvert(o,KEY_RAW,n);else{if(h=createFsWatchInstance(t,e,fsWatchBroadcast.bind(null,s,KEY_LISTENERS),r,fsWatchBroadcast.bind(null,s,KEY_RAW)),!h)return;h.on(EV_ERROR,async e=>{const i=fsWatchBroadcast.bind(null,s,KEY_ERR);if(o.watcherUnusable=!0,isWindows&&"EPERM"===e.code)try{const s=await open(t,"r");await close(s),i(e)}catch(t){}else i(e)}),o={listeners:a,errHandlers:r,rawEmitters:n,watcher:h},FsWatchInstances.set(s,o)}return()=>{delFromSet(o,KEY_LISTENERS,a),delFromSet(o,KEY_ERR,r),delFromSet(o,KEY_RAW,n),isEmptySet(o.listeners)&&(o.watcher.close(),FsWatchInstances.delete(s),HANDLER_KEYS.forEach(clearItem(o)),o.watcher=void 0,Object.freeze(o))}},FsWatchFileInstances=new Map,setFsWatchFileListener=(t,s,e,i)=>{const{listener:a,rawEmitter:r}=i;let n=FsWatchFileInstances.get(s),h=new Set,o=new Set;const l=n&&n.options;return l&&(l.persistent<e.persistent||l.interval>e.interval)&&(h=n.listeners,o=n.rawEmitters,fs.unwatchFile(s),n=void 0),n?(addAndConvert(n,KEY_LISTENERS,a),addAndConvert(n,KEY_RAW,r)):(n={listeners:a,rawEmitters:r,options:e,watcher:fs.watchFile(s,e,(e,i)=>{foreach(n.rawEmitters,t=>{t(EV_CHANGE,s,{curr:e,prev:i})});const a=e.mtimeMs;(e.size!==i.size||a>i.mtimeMs||0===a)&&foreach(n.listeners,s=>s(t,e))})},FsWatchFileInstances.set(s,n)),()=>{delFromSet(n,KEY_LISTENERS,a),delFromSet(n,KEY_RAW,r),isEmptySet(n.listeners)&&(FsWatchFileInstances.delete(s),fs.unwatchFile(s),n.options=n.watcher=void 0,Object.freeze(n))}};class NodeFsHandler{constructor(t){this.fsw=t,this._boundHandleError=s=>t._handleError(s)}_watchWithNodeFs(t,s){const e=this.fsw.options,i=sysPath.dirname(t),a=sysPath.basename(t);this.fsw._getWatchedDir(i).add(a);const r=sysPath.resolve(t),n={persistent:e.persistent};let h;return s||(s=EMPTY_FN),e.usePolling?(n.interval=e.enableBinaryInterval&&isBinaryPath(a)?e.binaryInterval:e.interval,h=setFsWatchFileListener(t,r,n,{listener:s,rawEmitter:this.fsw._emitRaw})):h=setFsWatchListener(t,r,n,{listener:s,errHandler:this._boundHandleError,rawEmitter:this.fsw._emitRaw}),h}_handleFile(t,s,e){if(this.fsw.closed)return;const i=sysPath.dirname(t),a=sysPath.basename(t),r=this.fsw._getWatchedDir(i);let n=s;if(r.has(a))return;const h=async(s,e)=>{if(this.fsw._throttle("watch",t,5))if(e&&0!==e.mtimeMs){if(r.has(a)){const s=e.atimeMs,i=e.mtimeMs;(!s||s<=i||i!==n.mtimeMs)&&this.fsw._emit(EV_CHANGE,t,e),n=e}}else try{const e=await stat(t);if(this.fsw.closed)return;const i=e.atimeMs,a=e.mtimeMs;(!i||i<=a||a!==n.mtimeMs)&&this.fsw._emit(EV_CHANGE,t,e),isLinux&&n.ino!==e.ino?(this.fsw._closeFile(s),n=e,this.fsw._addPathCloser(s,this._watchWithNodeFs(t,h))):n=e}catch(t){this.fsw._remove(i,a)}},o=this._watchWithNodeFs(t,h);if((!e||!this.fsw.options.ignoreInitial)&&this.fsw._isntIgnored(t)){if(!this.fsw._throttle(EV_ADD,t,0))return;this.fsw._emit(EV_ADD,t,s)}return o}async _handleSymlink(t,s,e,i){if(this.fsw.closed)return;const a=t.fullPath,r=this.fsw._getWatchedDir(s);if(!this.fsw.options.followSymlinks){let s;this.fsw._incrReadyCount();try{s=await fsrealpath(e)}catch(t){return this.fsw._emitReady(),!0}if(this.fsw.closed)return;return r.has(i)?this.fsw._symlinkPaths.get(a)!==s&&(this.fsw._symlinkPaths.set(a,s),this.fsw._emit(EV_CHANGE,e,t.stats)):(r.add(i),this.fsw._symlinkPaths.set(a,s),this.fsw._emit(EV_ADD,e,t.stats)),this.fsw._emitReady(),!0}if(this.fsw._symlinkPaths.has(a))return!0;this.fsw._symlinkPaths.set(a,!0)}_handleRead(t,s,e,i,a,r,n){if(t=sysPath.join(t,EMPTY_STR),!e.hasGlob&&!(n=this.fsw._throttle("readdir",t,1e3)))return;const h=this.fsw._getWatchedDir(e.path),o=new Set;let l=this.fsw._readdirp(t,{fileFilter:t=>e.filterPath(t),directoryFilter:t=>e.filterDir(t),depth:0}).on(STR_DATA,async n=>{if(this.fsw.closed)return void(l=void 0);const c=n.path;let d=sysPath.join(t,c);o.add(c),n.stats.isSymbolicLink()&&await this._handleSymlink(n,t,d,c)||(this.fsw.closed?l=void 0:c!==i&&(i||h.has(c))||(this.fsw._incrReadyCount(),d=sysPath.join(a,sysPath.relative(a,d)),this._addToNodeFs(d,s,e,r+1)))}).on(EV_ERROR,this._boundHandleError);return new Promise(s=>l.once(STR_END,()=>{if(this.fsw.closed)return void(l=void 0);const c=!!n&&n.clear();s(),h.getChildren().filter(s=>s!==t&&!o.has(s)&&(!e.hasGlob||e.filterPath({fullPath:sysPath.resolve(t,s)}))).forEach(s=>{this.fsw._remove(t,s)}),l=void 0,c&&this._handleRead(t,!1,e,i,a,r,n)}))}async _handleDir(t,s,e,i,a,r,n){const h=this.fsw._getWatchedDir(sysPath.dirname(t)),o=h.has(sysPath.basename(t));let l,c;e&&this.fsw.options.ignoreInitial||a||o||r.hasGlob&&!r.globFilter(t)||this.fsw._emit(EV_ADD_DIR,t,s),h.add(sysPath.basename(t)),this.fsw._getWatchedDir(t);const d=this.fsw.options.depth;if((null==d||i<=d)&&!this.fsw._symlinkPaths.has(n)){if(!a&&(await this._handleRead(t,e,r,a,t,i,l),this.fsw.closed))return;c=this._watchWithNodeFs(t,(s,e)=>{e&&0===e.mtimeMs||this._handleRead(s,!1,r,a,t,i,l)})}return c}async _addToNodeFs(t,s,e,i,a){const r=this.fsw._emitReady;if(this.fsw._isIgnored(t)||this.fsw.closed)return r(),!1;const n=this.fsw._getWatchHelpers(t,i);!n.hasGlob&&e&&(n.hasGlob=e.hasGlob,n.globFilter=e.globFilter,n.filterPath=t=>e.filterPath(t),n.filterDir=t=>e.filterDir(t));try{const e=await statMethods[n.statMethod](n.watchPath);if(this.fsw.closed)return;if(this.fsw._isIgnored(n.watchPath,e))return r(),!1;const h=this.fsw.options.followSymlinks&&!t.includes(STAR)&&!t.includes(BRACE_START);let o;if(e.isDirectory()){const r=sysPath.resolve(t),l=h?await fsrealpath(t):t;if(this.fsw.closed)return;if(o=await this._handleDir(n.watchPath,e,s,i,a,n,l),this.fsw.closed)return;r!==l&&void 0!==l&&this.fsw._symlinkPaths.set(r,l)}else if(e.isSymbolicLink()){const a=h?await fsrealpath(t):t;if(this.fsw.closed)return;const r=sysPath.dirname(n.watchPath);if(this.fsw._getWatchedDir(r).add(n.watchPath),this.fsw._emit(EV_ADD,n.watchPath,e),o=await this._handleDir(r,e,s,i,t,n,a),this.fsw.closed)return;void 0!==a&&this.fsw._symlinkPaths.set(sysPath.resolve(t),a)}else o=this._handleFile(n.watchPath,e,s);return r(),this.fsw._addPathCloser(t,o),!1}catch(s){if(this.fsw._handleError(s))return r(),t}}}module.exports=NodeFsHandler;